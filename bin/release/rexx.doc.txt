  
                            Xedit Version 2.0 
                          REXX Language Reference  
                           Online Documentation  
             Based on the REXX documentation by CTC for SPF/PC 4.0 
  
      *  Use Xedit to browse this documentation directly. Peruse the  
         Table of Contents. Find the desired text using the primary  
         command "locate" in the following form:  
  
             -[nnn]  
  
         where "nnn" is the desired page number.  
  
      The Table of Contents follows.  
  
  
  
  
                            Table of Contents  
  
  
  
  
   Introduction   . . . . . . . . . . . . . . . . . . . . . . . . . . 1  
     How To Use This Manual   . . . . . . . . . . . . . . . . . . . . 1  
     Where to Start   . . . . . . . . . . . . . . . . . . . . . . . . 2  
     How to Read the Syntax Diagrams  . . . . . . . . . . . . . . . . 2  
  
   Using REXX   . . . . . . . . . . . . . . . . . . . . . . . . . . . 4  
     Limits   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 4  
     Comparison of Built-In Functions   . . . . . . . . . . . . . . . 5  
     Differences from CMS REXX  . . . . . . . . . . . . . . . . . . . 6  
  
   Language Definition  . . . . . . . . . . . . . . . . . . . . . . . 7  
     Clauses  . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7  
     Tokens   . . . . . . . . . . . . . . . . . . . . . . . . . . . . 7  
       Comments   . . . . . . . . . . . . . . . . . . . . . . . . . . 7  
       Literal strings  . . . . . . . . . . . . . . . . . . . . . . . 8  
       Hexadecimal strings  . . . . . . . . . . . . . . . . . . . . . 8  
       Binary strings   . . . . . . . . . . . . . . . . . . . . . . . 9    
       Symbols  . . . . . . . . . . . . . . . . . . . . . . . . . .  10  
       Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . .  10  
       Operators and special characters   . . . . . . . . . . . . .  10  
       Implied semicolons   . . . . . . . . . . . . . . . . . . . .  10  
     Program Execution  . . . . . . . . . . . . . . . . . . . . . .  11  
  
   Clauses  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  11 
  
   Expressions  . . . . . . . . . . . . . . . . . . . . . . . . . .  13  
     Operators and Terms  . . . . . . . . . . . . . . . . . . . . .  13  
       Terms  . . . . . . . . . . . . . . . . . . . . . . . . . . .  13  
       Operators  . . . . . . . . . . . . . . . . . . . . . . . . .  13  
       Parentheses and operator precedence  . . . . . . . . . . . .  16  
  
   Variables  . . . . . . . . . . . . . . . . . . . . . . . . . . .  17  
     Symbols  . . . . . . . . . . . . . . . . . . . . . . . . . . .  17  
       Selecting a name for a variable  . . . . . . . . . . . . . .  18  
       Initial values   . . . . . . . . . . . . . . . . . . . . . .  18  
     Types of Symbols   . . . . . . . . . . . . . . . . . . . . . .  19   
       Constant symbols   . . . . . . . . . . . . . . . . . . . . .  19  
       Simple symbols   . . . . . . . . . . . . . . . . . . . . . .  19  
       Compound symbols   . . . . . . . . . . . . . . . . . . . . .  19  
       How REXX processes compound symbols  . . . . . . . . . . . .  20  
       Using compound symbols as arrays   . . . . . . . . . . . . .  20  
       When to use quotes   . . . . . . . . . . . . . . . . . . . .  21  
     Special Variables  . . . . . . . . . . . . . . . . . . . . . .  22  
  
   System Commands  . . . . . . . . . . . . . . . . . . . . . . . .  22  
  
   Keyword Instructions   . . . . . . . . . . . . . . . . . . . . .  23  
     ADDRESS  . . . . . . . . . . . . . . . . . . . . . . . . . . .  23  
     ARG  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  25  
     CALL   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  26  
     DO   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  28  
       Simple DO group  . . . . . . . . . . . . . . . . . . . . . .  30  
       Simple repetitive loop   . . . . . . . . . . . . . . . . . .  30  
       Controlled repetitive loop   . . . . . . . . . . . . . . . .  31  
       Conditional loop   . . . . . . . . . . . . . . . . . . . . .  32  
     DROP   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  32  
     EXIT   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  33  
     IF   . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  34  
     INTERPRET  . . . . . . . . . . . . . . . . . . . . . . . . . .  35  
     ITERATE  . . . . . . . . . . . . . . . . . . . . . . . . . . .  37  
     LEAVE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  38  
     NOP  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  39  
     PARSE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  40  
     PROCEDURE  . . . . . . . . . . . . . . . . . . . . . . . . . .  41  
     PULL   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43  
     PUSH   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  43  
     QUEUE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  44  
     RETURN   . . . . . . . . . . . . . . . . . . . . . . . . . . .  44  
     SAY  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  45  
     SELECT   . . . . . . . . . . . . . . . . . . . . . . . . . . .  46  
     SIGNAL   . . . . . . . . . . . . . . . . . . . . . . . . . . .  47  
     TRACE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  49  
       Interactive tracing and debugging  . . . . . . . . . . . . .  50  
       The format of TRACE output   . . . . . . . . . . . . . . . .  51  
  
   Functions  . . . . . . . . . . . . . . . . . . . . . . . . . . .  51  
     Types of Functions   . . . . . . . . . . . . . . . . . . . . .  52  
       Search order   . . . . . . . . . . . . . . . . . . . . . . .  52  
     Built-In Functions   . . . . . . . . . . . . . . . . . . . . .  53  
     ABBREV   . . . . . . . . . . . . . . . . . . . . . . . . . . .  55  
     ABS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  56  
     B2X  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  56  
     CHARIN   . . . . . . . . . . . . . . . . . . . . . . . . . . .  57  
     CHAROUT  . . . . . . . . . . . . . . . . . . . . . . . . . . .  59  
     CHARS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  60  
     COMPARE  . . . . . . . . . . . . . . . . . . . . . . . . . . .  61  
     COPIES . . . . . . . . . . . . . . . . . . . . . . . . . . . .  62 
     CONTAINS . . . . . . . . . . . . . . . . . . . . . . . . . . .  62 
     C2X  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  63  
     DATATYPE   . . . . . . . . . . . . . . . . . . . . . . . . . .  63  
     DATE   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  65  
     DELSTR   . . . . . . . . . . . . . . . . . . . . . . . . . . .  66  
     FORMAT   . . . . . . . . . . . . . . . . . . . . . . . . . . .  67  
     INSERT   . . . . . . . . . . . . . . . . . . . . . . . . . . .  68  
     LASTPOS  . . . . . . . . . . . . . . . . . . . . . . . . . . .  69  
     LEFT   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  70  
     LENGTH   . . . . . . . . . . . . . . . . . . . . . . . . . . .  71  
     LINEIN   . . . . . . . . . . . . . . . . . . . . . . . . . . .  71  
     LINEOUT  . . . . . . . . . . . . . . . . . . . . . . . . . . .  72  
     LINES  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  74  
     OVERLAY  . . . . . . . . . . . . . . . . . . . . . . . . . . .  75  
     POS  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  76  
     QUEUED   . . . . . . . . . . . . . . . . . . . . . . . . . . .  77  
     RANDOM   . . . . . . . . . . . . . . . . . . . . . . . . . . .  77  
     REVERSE  . . . . . . . . . . . . . . . . . . . . . . . . . . .  78  
     REGEXP . . . . . . . . . . . . . . . . . . . . . . . . . . . .  78  
     RXFUNCADD  . . . . . . . . . . . . . . . . . . . . . . . . . .  114
     RIGHT  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  79  
     SIGN   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  80  
     STREAM   . . . . . . . . . . . . . . . . . . . . . . . . . . .  80  
     STRIP  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  84  
     SUBSTR   . . . . . . . . . . . . . . . . . . . . . . . . . . .  84  
     TIME   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  85  
     TRACE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  87  
     TRANSLATE  . . . . . . . . . . . . . . . . . . . . . . . . . .  88  
     TRUNC  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  89  
     VALUE  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  90  
     VERIFY   . . . . . . . . . . . . . . . . . . . . . . . . . . .  91  
     WORD   . . . . . . . . . . . . . . . . . . . . . . . . . . . .  92  
     WORDS  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  93  
     XRANGE   . . . . . . . . . . . . . . . . . . . . . . . . . . .  93  
     X2B  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  94  
     X2C  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95  
  
   Parsing  . . . . . . . . . . . . . . . . . . . . . . . . . . . .  95  
     Parsing With Words   . . . . . . . . . . . . . . . . . . . . .  96  
     Parsing With Patterns  . . . . . . . . . . . . . . . . . . . .  97  
       Parsing with literal patterns  . . . . . . . . . . . . . . .  97  
       Parsing with variable patterns   . . . . . . . . . . . . . .  99  
       Parsing with numeric patterns  . . . . . . . . . . . . . . . 100  
       Parsing with positional patterns   . . . . . . . . . . . . . 100  
       Parsing with relative patterns   . . . . . . . . . . . . . . 101  
     Parsing More Than One String   . . . . . . . . . . . . . . . . 102  
  
   Numerics and Math  . . . . . . . . . . . . . . . . . . . . . . . 103  
     Numbers  . . . . . . . . . . . . . . . . . . . . . . . . . . . 103  
     Operators  . . . . . . . . . . . . . . . . . . . . . . . . . . 104  
     Arithmetic combination rules   . . . . . . . . . . . . . . . . 105  
       Addition and subtraction   . . . . . . . . . . . . . . . . . 105  
       Multiplication   . . . . . . . . . . . . . . . . . . . . . . 105  
       Division   . . . . . . . . . . . . . . . . . . . . . . . . . 105  
       Additional operators   . . . . . . . . . . . . . . . . . . . 106  
     Comparing Numbers  . . . . . . . . . . . . . . . . . . . . . . 107  
     Exponential notation   . . . . . . . . . . . . . . . . . . . . 107  
       Use of numbers by REXX   . . . . . . . . . . . . . . . . . . 108  
  
   Input and Output   . . . . . . . . . . . . . . . . . . . . . . . 108  
     Manipulating character streams   . . . . . . . . . . . . . . . 108  
       Manipulating input streams   . . . . . . . . . . . . . . . . 109  
       Manipulating output streams  . . . . . . . . . . . . . . . . 109  
       Manipulating the external data queue   . . . . . . . . . . . 110  
     Input/Output Examples  . . . . . . . . . . . . . . . . . . . . 110  
  
   Condition Traps  . . . . . . . . . . . . . . . . . . . . . . . . 108  
  
                                                                                         [1]

                                Chapter 1.
                               Introduction




      This REXX is a proper subset of IBM SAA language REXX which is
      hosted on MVS/TSO, VM/CMS, and OS/2 platforms.  REXX does not
      support non-SAA compliant instructions or functions nor any
      extensions which would render REXX non-portable.

      This manual explains how to use REXX in the context of a
      macro language extension to Xedit. While powerful and flexible,
      REXX is not intended to be a full blown programming language.

      Third party implementations with extensions to the core language
      are available for DOS, OS/2, UNIX and other operating system
      environments.

      The original specification for the REXX language can be found in
      the book The REXX Language: A Practical Approach to Programming
      by M.F. Cowlishaw (Prentice-Hall, 1985), ISBN 0-13-780735-X-01.
      The REXX Language provides a complete reference of the REXX
      language, the philosophy which shaped the language, and a histor-
      ical perspective of the language.

      A general introduction and tutorial for the REXX language can be
      found in the book Modern Programming Using REXX by R.P. O'Hara
      and D.G. Gomberg (Prentice-Hall, 1985).  Modern Programming Using
      REXX also provides an overview of programming and programming
      concepts. It is recommended both for programmers and
      non-programmers alike.

      A description of the REXX language, as implemented on the IBM
      VM/SP CMS operating system, can be found in the IBM publication
      VM/SP System Product Interpreter Reference, SC24-5239.  It is a
      reference manual recommended for experienced programmers.  An
      introduction and tutorial to the REXX language can be found in
      the IBM publication VM/SP System Product Interpreter User's
      Guide, SC24-5238.


   How To Use This Manual

      REXX contains a powerful set of control constructs, allowing a
      great degree of control, while remaining uncomplicated.  These
      constructs are implemented as REXX instructions.  A detailed
      description of each instruction is included in the section titled
      "Keyword Instructions" on page 23.

      REXX provides numerous built-in functions which perform a wide
      range of operations and types of operations (string, word, arith-



      metic, etc.).  The built-in functions are listed in tabular form,
      both alphabetically on page 51.  A detailed description of each 
                                                                                         [2]
      function is included in the section titled "Built-In Functions"
      on page 51.  Cross-referencing of related functions is included
      with each built-in function description.


   Where to Start

      *  If you are familiar with the REXX language, the included REXX
         Reference Summary may be the only documentation required.
         However, we suggest that you take a few moments to review the
         sections titled "Keyword Instructions", "Built-In Functions" 
         to reveal some of the recent enhancements to the language.

      *  If you are not familiar with the REXX language, but are
         familiar with programming in other languages, we suggest that
         you review the sections titled "Language Definition", "Keyword
         Instructions", and "Built-In Functions".  We also suggest that
         the sample programs contained in "Input/Output Examples
         on page 110 be reviewed.

      *  If you are not familiar with the REXX language, but are
         familiar with the system batch language, we recommend that you
         review the sample programs contained in "Input/Output Examples"
         on page 110.  These examples will give you a
         general "feel" for the language in a context similar to the
         way you used the system batch language.  The programs
         contained in "Input/Output Examples" on page 110
         provide examples of REXX programs which are out of the scope
         of the system batch language, but well within the scope of
         REXX. In addition, we suggest that you review the sections
         titled "Language Definition", "Keyword Instructions", and
         "Built-In Functions" in conjunction with reviewing the sample
         programs.  This will give you an example of the "rules" of the
         language while you are reading the "rules".


   How to Read the Syntax Diagrams

      In this book, the syntax of REXX commands and functions is illus-
      trated by the diagramming scheme described below.

      Syntax diagrams are read from left to right and top to bottom.
      Every syntax diagram begins a double right-arrow sequence
      (>>--  ) and ends with with a right-arrow/left-arrow sequence
      (--><  ).

      Keywords are indicated by upper-case text.  They must be be
      spelled exactly as shown.  For example, the statement below indi-
      cates that there are no parameters for the statement shown.

      >>--STATEMENT----------------------------------------------><



      User-supplied parameters are indicated by lower-case text.  These
      lower-case items are to be replaced with a value determined by
      the user.  When the syntax includes a required item, it appears
      in the main line.  Optional parameters are placed in a separate
      path below the main line.
                                                                                         [3]

      >>--STATEMENT----required-item-----------------------------><

      >>--STATEMENT--+-----------------+-------------------------><
                     +-optional-item---+

      Any commas, parenthesis, or other such punctuation marks must be
      entered as shown as part of the syntax.

      When the user may select from a number of alternate parameters,
      they are stacked vertically.

      >>--STATEMENT--+-required-item1--+-------------------------><
                     |                 |
                     +-required-item2--+

      >>--STATEMENT--+-----------------+-------------------------><
                     +-optional-item1--+
                     |                 |
                     +-optional-item2--+

      Single arrowheads have special meanings in the syntax diagrams.
      A right arrowhead at the end of a main line indicates that the
      diagram is continued, while a right arrowhead at the beginning of
      a main line indicates that it is a continuation of a preceding
      main line.

      >>--STATEMENT--+-required-item1--+--+-----------------+----->
                     |                 |  |                 |
                     +-required-item2--+  +-optional-item1--+
                                          |                 |
                                          +-optional-item2--+

      >------------+-----------------+---------------------------><
                   +-optional-item3--+

      Items which may optionally be repeated in a syntax are indicated
      by an arrow which returns to an earlier point in the path
      containing those items.

      >>--STATEMENT--+-------------------+-----------------------><
                     ||-----------------||
                     +“-repeatable-item-++




                                                                                         [4]
                                Chapter 2.
                                Using REXX




      REXX macros used with XeditPc have the following characteristic:

      1. The first line in the macro must be a comment in the form:

             /* ... */

      2. Subsequent lines may be REXX instructions intermixed with
         ISREDIT statements as desired.

      3. REXX macros for XeditPc have are named in the following manner:

          macro-name.rex

         and placed in directory \XEDITDNET. 

      1. REXX macros are invoked by specifying the macro in the primary
         command field and pressing ENTER.


   Limits

      This section lists the implementation limits for REXX.  These
      limits are mainly for reference; most REXX programs will not be
      affected by them.

      *  The size of a REXX program will vary depending on your avail-
         able memory and how you set the environmental variables.  REXX
         compiles source code into pseudo-code, and the pseudo-code for
         a single module must fit within 64K, but the actual source
         code can be much larger.

      *  The total size of all variables is limited only by the amount
         of virtual storage available to XeditPc.  This will vary
         depending on your available memory and how much disk space is
         available for swapping or paging.

      *  The total static nesting of control structures (IF, SELECT,
         DO, and so forth) is 250.

      *  The largest allowable exponent is 999,999,999.




                        Table 1. REXX Maximum Lengths


                           Item                       Maximum length

       Single line                                  32,700 characters
       Variable name                                32,700 characters
       Symbol (before substitution)                 32,700 characters
       Literal string                               32,700 characters
       Single "clause" (tokenized internal format)  32,700 tokens
       Single "token"                               32,700 characters
       Argument of INTERPRET instruction            32,700 characters
       Variable                                     32,700 characters

                        Table 2. REXX Maximum Numbers


                                             Maximum
                                Item         number

                         Function arguments    255
                         Open files            255


                                                                                         [5]

   Comparison of Built-In Functions

      The following table provides a comparison of Built-In Functions
      for VM/SP CMS REXX (CMS), M.F. Cowlishaw's definition (COW),
      Systems Application Architecture Procedures Language (SAA), and
      REXX.

                  Table 3. Comparison of Built-in Functions


                     Availability of Built-in Functions

                      Function    SAA   COW   CMS   Xedit

                     ABBREV        x     x     x     x
                     ABS           x     x     x     x
                     ADDRESS       x     x     x     -
                     ARG           x     x     x     -
                     BITAND        x     x     x     -
                     BITOR         x     x     x     -
                     BITXOR        x     x     x     -
                     B2X           x     -     -     x
                     CENTER        x     x     x     -
                     CHARIN        x     x     -     x
                     CHAROUT       x     x     -     x
                     CHARS         x     x     -     x
                     COMPARE       x     x     x     x
                     CONDITION     x     -     -     -
                     COPIES        x     x     x     x
                     C2D           x     x     x     -
                     C2X           x     x     x     x
                     DATATYPE      x     x     x     x
                     DATE          x     x     x     x
                     DELSTR        x     x     x     x
                     DELWORD       x     x     x     -
                     DIGITS        x     x     x     -
                     D2C           x     x     x     -
                     D2X           x     x     x     -
                     ERRORTEXT     x     x     x     -
                     FORM          x     x     x     -
                     FORMAT        x     x     x     x
                     FUZZ          x     x     x     -
                     INDEX         x     x     x     x
                     INSERT        x     x     x     x
                     LASTPOS       x     x     x     x
                     LEFT          x     x     x     x
                     LENGTH        x     x     x     x
                     LINEIN        x     x     -     x
                     LINEOUT       x     x     -     x
                     LINES         x     x     -     x
                     MAX           x     x     x     -
                     MIN           x     x     x     -
                     OVERLAY       x     x     x     x
                     POS           x     x     x     x
                     QUEUED        x     x     x     x
                                                                                         [6]
                     RANDOM        x     x     x     x
                     REVERSE       x     x     x     x
                     RIGHT         x     x     x     x
                     SIGN          x     x     x     x
                     SOURCELINE    x     x     x     -
                     SPACE         x     x     x     -
                     STREAM        x     -     -     x
                     STRIP         x     x     x     x
                     SUBSTR        x     x     x     x
                     SUBWORD       x     x     x     -
                     SYMBOL        x     x     x     x
                     TIME          x     x     x     x
                     TRACE         x     x     x     -
                     TRANSLATE     x     x     x     x
                     TRUNC         x     x     x     x
                     VALUE         x     x     x     x
                     VERIFY        x     x     x     x
                     WORD          x     x     x     x
                     WORDINDEX     x     x     x     -
                     WORDLENGTH    x     x     x     -
                     WORDPOS       x     x     x     -
                     WORDS         x     x     x     x
                     XRANGE        x     x     x     x
                     X2B           x     -     -     x
                     X2C           x     x     x     x
                     X2D           x     x     x     -



   Differences from CMS REXX

      This section lists the incompatibilities between REXX and CMS
      REXX (as of VM/SP Release 6).

      *  The underlying character set for REXX is ASCII instead of
         EBCDIC.

      *  Trace output is not indented according to the logical level of
         nesting for DO loops.

      *  Programs written for CMS REXX that make use of CMS commands
         and file naming conventions will have to be changed to run
         with REXX.

      *  REXX does not support the double byte character set.

      *  Since ASCII does not have a character for logical negation,
         REXX provides several alternatives. Wherever a logical not
         sign ( ª ) is used in CMS REXX, you can use either a ( ª ),
         backslash  ( \ ), or ( ^ ). A forward slash ( / ) is sometimes
         used in CMS REXX for negation, so REXX accepts it in the same
         cases, but we do not recommend its use.  The preferred
         character is backslash ( \ ).

      *  Quoted strings must fit on one line. In CMS REXX, quoted
         strings are allowed to cross line boundaries.

      *  REXX re-evaluates the DATE and TIME built-in functions on
         clause boundaries, rather than once in each expression evalu-
         ation.

                                                                                         [7]

                                Chapter 3.
                           Language Definition




   Clauses

      A REXX program is built out of a series of clauses.  Clauses are
      made up of blanks and tokens.  To place multiple clauses on one
      line, separate them with semicolons ( ; ).  To continue long
      clauses on the next line, use a comma ( , ).


   Tokens

      The REXX language is composed of tokens, which can be up to 250
      characters long.  Each clause can contain up to 250 tokens.

      Tokens are either separated by blanks or by the characteristics
      of the tokens themselves.

      The tokens are:

      *  Comments

      *  Literal strings

      *  Hexadecimal strings

      *  Symbols

      *  Numbers

      *  Operators

      *  Special characters


   Comments

      A comment is any sequence of characters of one or more lines that
      start with a   /*   and end with a   */  .  For example:

      /* This is a comment */

      You can nest comments, as long as the  /*  and  */  pair
      correctly.  You can put comments anywhere, and they can be as
      long as you like.

      Comments have no effect on the program, except that they act as
      separators.  For example, if you put a comment in between two
      tokens, REXX treats the tokens separately.


      We recommend that you start all your REXX programs with a comment
      that describes the program.
                                                                                         [8]


   Literal strings

      A literal string is a sequence of any characters, up to 250 char-
      acters long.  Literal strings are delimited by the single quote
      character ( ' ) or the double quote ( " ).

      A literal string is a constant and REXX never modifies its
      contents.  Literal strings must be complete on a single line
      (this means that quotes must match on a single line).

      A literal string that contains no characters (that is, a string
      of length 0) is called a null string.

      For example, these are valid literal strings:

      'Rick'
      "Say When"
      'You can''t'     /* Same as "You can't" */
      ''               /* A null string       */

      Note:  If a literal string is followed immediately by a left
      parenthesis, REXX recognizes it as the name of a function.    If
      a literal string is followed immediately by an "X", REXX recog-
      nizes it as a hexadecimal string.


   Hexadecimal strings

      A hexadecimal string is any sequence of zero or more hexadecimal
      digits (0-9, a-f, A-F), grouped in pairs.  The first group can
      have an odd number of digits, in which case REXX assumes a '0'
      digit to the left of the first digit.  You can optionally sepa-
      rate the groups of digits by one or more blanks.  The whole
      sequence is delimited by single quotes or double quotes and imme-
      diately followed by the character "x" or "X".  (The X cannot be
      part of a longer token).  The blanks can only be present at byte
      boundaries.  Blanks are used to improve readability; REXX ignores
      them.  No leading or trailing blanks are allowed.

      To form a hexadecimal string into a literal string, REXX packs
      the hexadecimal codes.  This lets you include characters in a
      program even if you cannot enter them directly.

      These are valid hexadecimal strings:

      'ABCD'x
      "1d ec f8"X
      '123 45'x    /* Same as '01 23 45'x */



                                                                                         [9]

   Binary strings

      Any sequence of zero or more binary digits (0 or 1) in groups of
      eight (bytes) or four (nibbles), optionally separated by one or
      more blanks.  If the leftmost group is not a multiple of four
      digits, it is padded with up to three zeros on the left to make a
      multiple of four digits.  The string is delimited by matching
      single or double quotes and immediately followed by the character
      "b" or "B".  No leading or trailing blanks are allowed.

      These are valid binary strings:

      '01110001'b
      '0111 0001'B
      "01110001 01011010"B
      '101 1110'b


   Symbols

      Symbols are identifiers made from alphanumeric characters (A-Z,
      a-z, 0-9), and/or from the national currency symbols (including
      the symbols for dollar, cent, and pound-sterling) and/or from the
      characters @ # . £ and underscore.  REXX translates any lower-
      case alphabetic character in a symbol to upper case before use.
             
      REXX determines a symbol's meaning depending on the context in
      which it is used.  A symbol can be a constant (such as a number),
      a keyword, a function, or the name of a variable.

      For example, these are valid symbols:

      date
      Time.Of.Day
      WHAT$

      A symbol can include other characters in one case only.  A symbol
      that starts with a digit (0-9) or period and ends in "E" or "e",
      and is followed immediately by a sign ( +  or  - ) and some
      digits is recognized as a number in exponential notation.  For
      example:

      32.1E-52
      .05E-8


   Numbers

      Numbers are character strings of one or more decimal digits.  A
      number can be preceded by a plus or minus sign, and can include a
      single period ( . ) to represent a decimal point.  A number can
      also be expressed in exponential notation:  an "E" (upper or
      lower case) followed optionally by a plus or minus sign then
      followed by one or more decimal digits defining the power of ten.

      Whenever REXX uses a character string as a number, rounding might
      occur.  The precision is specified by the NUMERIC DIGITS instruc-
      tion (the default is nine digits).

      Numbers can have leading blanks (before and/or after the sign, if
                                                                                         [10]
      any) and trailing blanks.  Blanks cannot be embedded among the
      digits of a number or in the exponential part.  Note that a
      symbol and a literal string can be a number.  A number cannot be
      the name of a variable.

      For example, these are valid numbers:

      -45.7
      639.0340
      22
      1E000
      -45.7
      88e+450
      ' +2.1E3 '

      A whole number in REXX is a number that has no decimal part, and
      which does not have more digits before the decimal point than the
      current setting of the NUMERIC DIGITS instruction (the default is
      9 digits).


   Operators and special characters

      REXX defines the characters + - * / & = \ % | ^ > < and various
      combinations of these as operators.  One or more blank charac-
      ter(s) in an expression can also act as an operator, if they are
      not adjacent to another operator.

      REXX defines the characters , ; : ) ( and the operator tokens as
      "special characters", because they have special significance when
      placed outside of literal strings.  They all act as token deli-
      miters.  REXX removes any blanks adjacent to them, with the
      exception that it only deletes a blank adjacent to the outside of
      a parenthesis if it is also adjacent to another special charac-
      ter.

      For example, the following clause is made up of six tokens:

      'ERASE'     Z - 3;

      The tokens are:  a literal string, a blank operator, a symbol
      (which can have a value), an operator, a second symbol (a
      number), and a semicolon.  REXX removes the blanks between the
      "Z" and the "-" and between the "-" and the "3".  One of the
      blanks between the "ERASE' and the "Z" remains as an operator.
      With the blanks removed, the clause is the same as:

      'ERASE' Z-3;





   Implied semicolons

      REXX implies a semicolon at the end of each line, except if:

      1. The line ends in the middle of comment.

                                                                                         [11]
      2. The last non-comment token was a comma.  In this case the
         comma is functionally replaced by a blank, and acts as a
         continuation character.

      This means that you only need to use semicolons to separate
      multiple clauses on a single line.

      Notes:

      1. REXX adds semicolons automatically after colons (when
         following a single symbol, a label) and after certain keywords
         (ELSE, OTHERWISE, and THEN) when in the correct context.

      2. The comment delimiter character pairs /* and */ cannot be
         split by a line-end.  If they are split, REXX cannot recognize
         them.


   Program Execution

      REXX ignores the blanks and scans each clause from left to right
      before it identifies the tokens and executes.  As the program
      executes, REXX:

      1. Recognizes instruction keywords, removes the comments, and
         reduces multiple blanks to single blanks (except within
         literal strings).

      2. Removes any blanks adjacent to special characters (including
         operators).



                                Chapter 4.
                                 Clauses




      A REXX program consists of a number of clauses.    A clause can
      be:

      *  A keyword instruction that tells REXX to do something; for
         example:

         say "enter your password"

         This keyword instruction tells REXX to display "enter your
         password" on the user's screen.

         Instructions control the external interfaces, the flow of
         control, and so on.  Some instructions, such as DO, can
         include nested instructions.  See "Keyword Instructions" on
         page 23.

      *  A null clause, such as a blank line or a comment line.  For
         example:

         ;
                                                                                         [12]

         REXX ignores a null clause, unless it is a comment line, in
         which case it is traced, if appropriate.

         Note: A null clause is not an instruction.  So, for example,
         if you put an extra semicolon after the THEN or ELSE in an IF
         instruction, it is not equivalent to a dummy instruction (as
         it is in PL/I).  REXX provides the NOP instruction for this
         purpose.

      *  A label, which is a single symbol followed by a colon.  For
         example:

         SUBNAME: REPEAT

         In this example, SUBNAME: is a label that tells REXX the name
         of a subroutine.

         The colon after a label implies a semicolon (clause separa-
         tor), and so a label is a clause in its own right and does not
         require a semicolon.  You can use labels to identify the
         targets of CALL instructions, SIGNAL instructions, and
         internal function calls.

         For example, the instruction:

         CALL SUBNAME


         tells REXX to search for the label SUBNAME:.

         You can also trace labels to aid debugging.

         Any number of successive clauses can be labels.   This permits
         multiple labels before other clauses.  REXX permits duplicate
         labels, but passes control only to the first of any duplicates
         in a program.  You can trace other duplicate labels, but you
         cannot use them as a target of a CALL, SIGNAL, or function
         invocation.

      *  An assignment, which gives a variable a new value.  For exam-
         ple:

         Message = 'The total'

         This means that the string "The total" is to be put into a
         place called "Message" in the computer's memory.  See "Vari-
         ables" on page 17.

         Anything that is not an instruction, an assignment, a label,
         or a null clause is taken to be:

      *  A command that is passed to the system.  For example:

         dir    /* display current directory */

         A command is a single clause that consists of just an expres-
         sion. The system processes the command just as if you had
         typed the command at the command prompt.  See "System
         Commands" on page 22.
                                                                                         [13]


                                Chapter 5.
                               Expressions




      Clauses can contain expressions.  An expression is something that
      can be computed.

      Expressions combine one or more pieces of data in various ways to
      produce a result, usually different from the original data.

      For example:

      1 + 1      /* The value is '2'     */


   Operators and Terms

      An expression can include operators that operate on one or more
      terms.


   Terms

      A term can be:

      *  Literal strings (character strings delimited by quotes), which
         are constants.

      *  Symbols (no quotes), which REXX translates to upper case.
         Those symbols that do not begin with a digit or a period can
         be the name of a variable, in which case REXX uses the value
         of that variable.  Otherwise, REXX treats them as a constant
         string.  A symbol can also be compound.  See "Compound
         symbols" on page 19.

      *  Function calls (see "Functions" on page 51) which are of the
         form:

         >>---symbol(----+------------------+-)-----------><
                         | |-------,------| |
                         +-“+------------++-+
                            +-expression-+

      *  Subexpressions, which consist of any expression bracketed by a
         left and right parenthesis.


   Operators

      Operators are divided into four groups:  concatenation, arithme-
      tic, comparative, and logical.


                                                                                         [14]
   Concatenation operators
      Concatenation operators combine two strings to form one string.
      REXX appends the second string to the right end of the first
      string.  The concatenation can occur with or without an
      intervening blank.  For example:

                      Table 4. Concatenation Operators


        Operator                      Description

        (blank)   Concatenate terms with one blank in between
           ||     Concatenate terms without an intervening blank
       (abuttal)  Concatenates a literal string and a symbol without
                  an intervening blank.  For example, if the variable
                  SUM had the value '13.7', then SUM'%' evaluates to
                  '13.7%'.


   Arithmetic operators

      Arithmetic operators combine character strings that are valid
      numbers.  The arithmetic operators are:

                        Table 5. Arithmetic Operators


        Operator                      Description

           +      Add
           -      Subtract
           *      Multiply
           /      Divide
           %      Integer divide.  Divide and return the integer part
                  of the result.
           //     Remainder.  Divide and return the remainder (not
                  modulo, as the result might be negative).
           **     Power.  Raise a number to a whole-number power.
        Prefix -  Same as the subtraction:  "0-number".
        Prefix +  Same as the addition:  "0+number".

      See "Numerics and Math" on page 103.


   Comparative operators

      Comparative operators return the value '1' if the result of the
      comparison is true, or '0' if false.  REXX defines two types of
      comparative operators:  the strict comparisons and the normal
      comparisons.

      The strict comparative operators all have one of the characters
      defining the operator doubled.  The "==" and "\==" operators test
      for strict equality or inequality between two strings.  These
      operators are useful if you are interested in leading and


      trailing blanks, nonsignificant zeros and so forth.  The two
      strings must be identical before they are considered strictly
                                                                                         [15]
      equal.  Similarly, the other strict comparative operators (such
      as ">>" or "<<") carry out a simple character-by-character
      comparison, with no padding of either of the strings being
      compared.

      For all the other comparative operators, if both the terms
      involved are numeric, REXX performs a numeric comparison in which
      leading zeros are ignored, and so forth  (see "Comparing Numbers"
      on page 107).  Otherwise, REXX treats both terms as character
      strings.    For character string comparison, REXX ignores leading
      and trailing blanks, and pads the shorter string with blanks on
      the right.  The character comparison operation is case sensitive,
      and (as for strict comparisons) the exact collating order might
      depend on the character set used.

      Normal comparative operators are:

                    Table 6. Normal Comparative Operators


                 Operator            Description

                 =        True if the terms are equal
                 \=, ^=   Not equal (inverse of =).
                 >        Greater than.
                 <        Less than.
                 <>       Greater than or less than (same as
                          not equal).
                 >=,      Greater than or equal to, not less
                 \<, ^<   than.
                 <=,      Less than or equal to, not greater
                 \>, ^>   than.



      Strict comparative operators are:

                    Table 7. Strict Comparative Operators


                  Operator             Description

                ==           True if the terms are strictly
                             equal (identical).



      The logical, or Boolean, operators negate or combine expressions.
      A character string is taken to have the value "false" if it is
      '0', and "true" if it is '1'. The logical operators take these
      values and return '0' or '1' as appropriate.


   Logical operators

      Logical operators are:

                         Table 8. Logical Operators

                                                                                         [16]

            Operator                     Description

         &               And.  Returns 1 if both terms are true.
         |               Inclusive or.  Returns 1 if either term is
                         true.
         Prefix  \, ^   Logical not.  Negates; 1 becomes 0 and 0
                         becomes 1.

      Most operators act on two terms, and there are at least one of
      these dyadic operators between every pair of terms.  A term can
      also contain prefix (monadic) operators, that act on the term
      immediately to the right of the operator.  A term can have one or
      more prefix operators to the left.


   Parentheses and operator precedence

      REXX resolves expressions from left to right.    You can modify
      this by using parentheses, because expressions in parentheses are
      resolved first.  Also, some operators have a greater priority
      than others, and are always executed first.

      The order of precedence of the operators is (highest at the top):

                        Table 9. Operator Precedence


                  Operator                      Description

        + - ª \                       Prefix operators
        **                            Power operator
        * / % //                      Multiplication and division
                                      operators
        + -                           Addition and subtraction opera-
                                      tors
        (blank) || (abuttal)          Concatenation operators
        =  ==  >  <  >=  <<           Comparison operators
        etc.
        &                             And
        |                             OR 



      For example,  *  (multiply) has a higher precedence than  +
      (add), so 3+2*5 evaluates to 13 (rather than the 25 that would
      result if strict left to right evaluation occurs).  If you wanted
      to perform the addition before the multiplication, you could
      write the expression (3+2)*5, which forms the first three tokens
      into a subexpression by adding the parentheses.

      When REXX encounters parentheses, it evaluates the entire subex-
      pression between the parentheses immediately when the term is
      required.

      REXX resolves the whole expression, except when an error occurs
      during the resolution.

      REXX resolves each term in an expression as it is used.  The
                                                                                         [17]
      result is a "typeless" character string.  Consequently, the
      result of evaluating any expression is itself a typeless
      character string.  All terms and results can be the null string
      (a character string of length 0).  REXX does not impose any
      restriction on the maximum length of results, but there are
      usually some practical limitations, depending on the amount of
      storage and other resources available during execution.

      Note: The REXX order of precedence has one difference from some
      common notations:  the prefix minus operator always has a higher
      priority than the exponential operator.  For example:

      -3**2       @ 9  /* not -9 */
      -(2+1)**2   @ 9  /* not -9 */

      In the following examples, suppose that the symbol A is a vari-
      able whose value is '3', and DAY is a variable with the value
      "Sunday".

      a+5             @ '8'
      a-4*2           @ '-5'
      a/2             @ '1.5'
      0.5**2          @ '0.25'
      (a+1)>7         @ '0'     /* False */
      ' '=''          @ '1'     /* True  */
      ' '==''         @ '0'     /* False */
      (a+1)*3=12      @ '1'     /* True  */
      '077'>'11'      @ '1'     /* True  */
      Today is day    @ 'TODAY IS Sunday'
      'If it is' day  @ 'If it is Sunday'
      substr(day,2,3) @ 'und' /* Substr is a function */
      '!'xxx'!'       @ '!XXX!'


 
 Variables


      A variable is a particular piece of data whose value can be
      changed during the execution of a REXX program.    The process of
      changing the value of a variable is called an assignment.  In an
      assignment, you name a variable and give it a value.  You can use
      an assignment to assign an initial value to a variable or to
      change its value.  A variable's value changes, not its name.

      The value of a variable is a single character string, of any
      length, that can contain any characters.


   Symbols

      A symbol is the name of the variable, for example, rick is the
      symbol in this assignment:

      /* Next line gives RICK the value 'Richard' */
      rick='Richard'

                                                                                         [18]
      The most common way to change the value of a variable is to use
      an assignment clause.  Any clause of the form:

      >>-symbol-=-expression-;-----------------------------------><

      is an assignment.  REXX resolves what the expression is and puts
      the result into the variable called symbol.

      You can also assign a new value to a variable using the ARG,
      PARSE, or PULL instructions.  See "Parsing" on page 95.


   Selecting a name for a variable

      Choosing descriptive variable names can do a great deal to
      improve the clarity of your program.  For example, the variable
      name total is much more meaningful than t.  However, if the vari-
      able represents a temporary concept, such as a loop index vari-
      able, a short name might be best.

      You can select any symbol as the name of a variable, with these
      restrictions:

      1. The first character must be one of:

         A B C ... Z @ # $ _ £




         The symbol that names the variable cannot begin with a digit
         (0-9) or a period.

      2. The rest of the characters can be any of the above, or 0
         through 9 or period ( . ).

      Note: You should not use a period in a variable name unless you
      understand the rules for compound symbols.  See "Compound
      symbols" on page 19.


   Initial values

      You can use symbols in an expression even if they have not been
      assigned a value.  When REXX finds a symbol (a word that is not
      in quotes) it looks to see if the symbol has been given a value.
      If so, REXX substitutes that value for the symbol.  If not, the
      variable is uninitialized, and REXX translates the symbol to
      uppercase and uses that.  For example:

      /* If "richard" has not been assigned a value, */
      /* next line gives RICK the value 'RICHARD'    */
      rick=richard


   Types of Symbols

      The meaning of a symbol varies according to its context.  When
      you use a symbol as a term in an expression (rather than as a
                                                                                         [19]
      keyword of some kind, for example), symbols are divided into four
      groups:  constant symbols, simple symbols, compound symbols, and
      stems.


   Constant symbols

      A constant symbol is simply the string that consists of the char-
      acters of the symbol.  You cannot assign a new value or change
      the value of a constant symbol.  The symbol starts with a digit
      (0-9) or a period.  REXX translates any alphabetic characters to
      upper case.

      These are constant symbols:

      77
      827.53
      .12345
      12e5           /*Same as 12E5 */


   Simple symbols

      A simple symbol is used for variables where the name corresponds
      to a single value.  By default the value of a simple symbol is




      the characters of the symbol, translated to upper case.  If you
      assign a value to the symbol, it names a variable and its value
      is the value of that variable.

      A simple symbol does not contain any periods, and does not start
      with a digit (0-9).

      These are simple symbols:

      RICK
      Reallybigmoney  /*Same as REALLYBIGMONEY */
      $25


   Compound symbols

      A compound symbol is used to build complex collections of vari-
      ables, such as arrays, records, and lists.  Compound symbols have
      one or more periods, which divide them into two parts.

      Here are examples of compound symbols:

      rick.3
      Array.R.N

      The leftmost part is a regular variable name, followed by a
      period.  This part is called the stem.  For example:

      rick.3

                                                                                         [20]
      The stem contains at least one period, and at least one other
      character.  It cannot start with a digit or a period.

      The rest of the compound symbol is composed of parts that are
      separated by a period.  If there is only one period, it cannot be
      the last character.  This is the tail.  A tail can be composed of
      constant symbols, simple symbols, or can be null.  For example:

      rick.3


   How REXX processes compound symbols

      Before REXX uses a compound symbol, it first generates a derived
      compound symbol name.


   Stem assignment

      If you have not assigned a value to the stem, by default its
      value is the symbol itself, translated to uppercase.

      By assigning a value to the stem, you can set all possible
      compound variables derived from the same stem.  Any reference to
      any compound variable with that stem will use the original stem
      assignment, until you assign a new value to the stem.


   Tail assignment

      To generate a derived name for the tail, REXX substitutes the
      values of any simple symbols in the tail by their values.  The
      value substituted can contain any characters (including periods).
      Substitution is only done once.

      For example, for the compound symbol array.r.n, REXX sets the
      simple symbols r and n to their values.  So if r was set to 3,
      and n was set to 5, the new derived name for the compound symbol
      is array.3.5.

      If you have not assigned values for the simple symbols, REXX uses
      their own name in uppercase, for example, ARRAY.R.N.

      Note: The value that has been assigned to the whole collection of
      variables can always be obtained by using the stem.

      You can also manipulate collections of variables, referred to by
      their stem, using the DROP and PROCEDURE instructions.  For exam-
      ple, "DROP RICK." drops all variables with that stem, and
      "PROCEDURE EXPOSE RICK." exposes all possible variables with that
      stem.


   Using compound symbols as arrays

      REXX's compound symbols are even more powerful than high-level
                                                                                         [21]
      data types in other languages, because their subscripts do not
      have to be numeric.  This lets you create trees, lists, and
      tables that usually need complex string manipulation and memory
      management.  Nonnumeric subscripts let you create high-level data
      structures that are automatically indexed by their contents.


   When to use quotes

      REXX reserves a few simple symbols in certain contexts:

      *  Within particular instructions, REXX reserves some symbols
         that separate the parts of an instruction.  For example, the
         subkeyword WHILE in a DO instruction, or the subkeyword THEN
         following an IF or WHEN clause.  In this case, THEN acts as a
         clause terminator.

      *  REXX checks simple symbols that are the first token in a
         clause to see if they are instruction keywords.

      Therefore keywords can have adverse affects when you execute a
      host command with the same name as a REXX keyword, for example,



      "QUEUE".  This is a potential problem for any program that might
      be in use for some time and needs to be very reliable.  There are
      several strategies you can use to get around this problem.
      REXX's syntax does not impose any of these rules, so the choice
      of strategy (if done at all) is voluntary.

      *  You can adopt the rule that all REXX programs must be written
         with (at least) the first word in every command enclosed in
         quotes.  For example:

         'Queue'

         This has two advantages:  it is more efficient, and you can
         use the the SIGNAL ON NOVALUE instruction to assure the
         program's integrity.


      Notes:

      1. REXX supports variable names whose length, after substitution,
         might become 250 characters.

      2. When you change a variable by the ARG, PARSE, or PULL instruc-
         tions, the effect is identical to an assignment.  Therefore,
         if you use a stem in a parsing template, it can set an entire
         collection of variables.

      3. Since an expression can include the operator "=", and an
         instruction can consist purely of an expression, there is a
         potential ambiguity which is resolved by the following rule:
         any clause that starts with a symbol and whose second token is
         "=" is an assignment, rather than an expression. 

         If you unintentionally use a REXX keyword as the variable name
                                                                                         [22]
         in an assignment, it is an error.  For example, the following 
         clause is an invalid assignment, not a CALL instruction:

         call='466-7002';

      4. You can use the SYMBOL function to test whether a symbol has
         been assigned a value.  You can also set SIGNAL ON NOVALUE to



         trap the use of any uninitialized variable. See the SIGNAL 
         instruction on page 47.


   Special Variables

      REXX has three special variables that it might set automatically
      during program execution:

      RC     Contains the value set by the last host command executed
             (including those submitted with the ADDRESS instruction).

      RESULT Contains the value set by a RETURN instruction, if it
             specifies an expression.  If the RETURN instruction does
             not specify an expression, RESULT is dropped (becomes
             uninitialized).

      SIGL   Contains the line number of the last call to a label (that
             is, any SIGNAL, CALL or internal function invocation).

      The special variables do not have an initial value.  A user can
      alter them, just like any other variable, but REXX will continue
      to set them automatically when appropriate.  The PROCEDURE and
      DROP instructions also affect these variables in their usual way.


                                Chapter 7.
                             System Commands




      REXX lets you execute system commands.

      REXX selects the system environment as the active environment for
      executing commands on entry to a REXX program.

      To send a command to the system, use a clause of the form:

      >>-expression----------------------------------------------><

      REXX evaluates the expression, which results in a character
      string that is sent to the system. The system executes the
      command, which might have side effects.  The system eventually
      returns control to REXX, after it sets a return code. REXX places
      this return code in the special variable RC.

      If an error or failure occurs, the system indicates the error or
                                                                                         [23]
      failure to REXX. An error is a condition for which a program that
      uses that command would normally be expected to be prepared.  A
      command failure occurs when a program that uses that command
      would not normally be expected to recover (for example, if the
      command was not executable or could not be found).


                                Chapter 8.
                           Keyword Instructions




      A keyword instruction is one or more clauses that perform
      actions, such as:

      *  Directing the flow of execution

      *  Controlling input and output

      *  Controlling arithmetic operations

      *  Executing other instructions

      The first clause of a keyword instruction begins with a keyword
      that identifies the instruction.

      REXX recognizes a keyword instruction if:
      Its keyword is the first token in a clause 

      REXX uses the same rules to recognize the keywords ELSE, END,
      OTHERWISE, THEN and WHEN.  If these keywords are not in their
      correct position in a DO, IF, or SELECT instruction, REXX issues
      a syntax error.

      Instruction keywords are reserved, therefore you cannot use them
      as labels or as the names of variables.  We recommend
      that you use them only as instructions.

      Some instructions have subkeywords that might be reserved within
      the clauses of the instructions.  For example, the symbols TO and
      WHILE in the DO instruction.  The DO instruction is described on
      page 28.



   --------------------------------------------------------------------
                                 ADDRESS
   --------------------------------------------------------------------


   Purpose

      Effects a temporary or permanent change to the destination of
      commands.  Commands are strings sent to an external environment.
      They can also be sent by clauses that consist of just an expres-
      sion, without using the ADDRESS instruction.

   Syntax
                                                                                         [24]

      >>-ADDRESS----environment-+------------+-----;-------------><
                                +-expression-+   

   Parameters

      environment The name of the environment to which you want to send
                  a command.  Environment is a single symbol or literal
                  string, which is taken as a constant.

                  REXX resolves the expression, and submits the
                  resulting command string to the environment.  After
                  the command executes, environment is returned to its
                  previous setting.

                  If you specify the null string as the expression,
                  ADDRESS sends all following commands to this environment.

   Example

      To send a single command to a select environment, specify the
      environment name, followed by an expression.  For example, the
      following instruction sends the command "DIR MDV1.ALL" to the
      environment called CMD:

      address CMD 'DIR MDV1.ALL'

      REXX sets the special variable RC, just as it does for other
      commands.  See page 22.  It also traps or traces any errors or
      failures in the commands, as usual.




   Example

      Use environment VALUE to make a lasting change to the environment.

      ADDRESS 'ENVIR' || number

      In this example, REXX resolves the expression (which can be just
      a variable name), and the result forms the name of the environ-
      ment.  

   Example

      If you specify only an environment name, ADDRESS selects a new
      environment for commands.  This routes all following commands to
      a new command environment, until you execute the next ADDRESS
      instruction.  REXX saves the previously selected environment.

      address CMD      /* Send command to the system */
      'RENAME *.DOC *.TXT'

      if rc=0 then
         'COPY *.TXT *.REX /V'
      address Xedit     /* Now all commands to Xedit */


                                                                                         [25]
   --------------------------------------------------------------------
                                   ARG
   --------------------------------------------------------------------


   Purpose

      Retrieves the argument strings provided to a program or internal
      routine and assigns them to variables.

   Syntax

      >>-ARG--+----------+--;------------------------------------><
              +-template-+

   Parameter

      template A list of symbols separated by blanks and/or patterns.

   Remarks

      1. ARG is just a shorter form of the instruction

         >>-PARSE UPPER ARG--+----------+--;----------><
                             +-template-+

         ARG translates the argument strings to upper case and parses
         them into variables according to the parsing rules. See "Pars-
         ing" on page 95.  If you do not want the argument strings
         translated to upper case, use the PARSE ARG instruction.

      2. If a subroutine or internal function is executing, ARG uses
         the argument string(s) passed to the routine.  Otherwise ARG
         uses the argument string(s) from the program invocation.

      3. You can execute the ARG (and PARSE ARG) instructions
         repeatedly (typically with different templates).  They will
         always parse the same current data.  The only restrictions on
         the length or content of the data parsed are those imposed by
         the caller.

      4. If more than one string is available to the program or
         routine, you can use a comma in the parsing template to select
         each string in turn. A parameter to a main Rexx program always 
         consists in only one string. Internal routines may have more strings.


 
   Example

      /* String passed to MYREXXPROG is 'Vida Loca' */

      arg adjective noun .

      /* Now:  ADJECTIVE contains 'VIDA'            */
      /*       NOUN      contains 'LOCA'            */

   Example

                                                                                         [26]
      This example uses a comma in the parsing template to select each
      string in turn.

      /* Function is invoked by   RICK('Now is',1,5) */

      Rick:   arg string, num1, num2

      /* Now:  STRING contains  'NOW IS'             */
      /*       NUM1   contains  '1'                  */
      /*       NUM2   contains  '5'                  */


   --------------------------------------------------------------------
                                   CALL
   --------------------------------------------------------------------


   Purpose

      Invokes a routine.  The routine can be an internal routine, an
      external routine, or a built-in function.

   Syntax

      >>-CALL----name-+---------------+------------;-------------><
                      | |-----,-----| |           
                      +-“-expression+-+           

   Parameters

      name       A symbol, which is taken as a constant, or a literal
                 string.  If you use a literal string for name, that
                 is, you specify the name in quotes, REXX bypasses the
                 search for internal routines, and invokes only a
                 built-in function or an external routine.  The literal
                 string must exactly match the name of the built-in
                 function or external routine, so if the name is in
                 upper case, the name in the literal string should also
                 be in upper case.


      REXX resolves any expressions that follow the name from left to
      right, and forms the argument strings while it executes.


      The CALL instruction then branches to the routine called name
      using exactly the same mechanism as function calls.  See "Func-
      tions" on page 51.  The search order is:

      1. Internal  Internal routines are sequences of REXX instructions 
              inside the same program, which start at the label that matches 
              the symbol name. The RETURN instruction completes the execu-
              tion of the routine.

      2. Built-inBuilt-in functions are defined as part of REXX.    All
              built-in functions return a string that contains the
              result of the function.

      3. External A routine that resides in a separate file from the
                                                                                         [27]
              program that uses it is called an external routine. The 
              CALL instruction can invoke a REXX program as a subroutine,
              and in this case you can pass the program more than one
              argument string.

      Eventually the routine executes a RETURN instruction, and at that
      point control returns to the clause following the original CALL
      instruction for completion.  If the RETURN instruction specifies
      an expression, it sets the special variable RESULT to the value
      of that expression.  Otherwise it uninitializes the special vari-
      able RESULT.

   Remarks

      1. You can include up to 255 argument expressions on a CALL
         instruction.

      2. The ARG and PARSE ARG instructions (and the ARG built-in func-
         tion) access the strings that form during execution rather
         than any active previously until control returns to the CALL
         instruction.

      3. While an internal routine executes, all variables previously
         known are accessible.  However, you can use the PROCEDURE
         instruction to set up a local variables environment to protect
         the subroutine and caller from each other.

      4. Calling an external program as a subroutine is similar to
         calling an internal routine.  However, the external routine
         protects its variables from the caller's variables and its
         internal values start with their defaults rather than
         inheriting the caller's internal values.  Another difference
         is that you can use the the EXIT instruction to return from
         the routine.

      5. To expose the selected variables to a internal routine, use
         the PROCEDURE EXPOSE instruction.



      6. REXX automatically saves the following internal values before
         executing a subroutine or function.  When the routine returns,
         REXX restores this information to its original status.

         Address settings:   The current and secondary command destina-
         tions.  See the ADDRESS instruction on page 23.

         The status of DO loops and other control structures:   It is
         safe to execute a SIGNAL instruction within a subroutine
         because it does not deactivate any DO loops or similar
         constructions that are active when the subroutine is called.
         It does, however, deactivate any loops that are active within
         the current routine.

         Elapsed time clocks:   A subroutine inherits the elapsed time
         clock from its caller, and the clock is saved across routine
         calls.  See the TIME function on page 85.  This means a
         subroutine or internal function can independently restart and
         use the clock without affecting its caller.  For the same
                                                                                         [28]
         reason, a clock started within an internal routine is not
         available to the caller.

         Trace settings:   Once you debug a subroutine, you can insert
         a "TRACE Normal" at the beginning of it, and this will not
         affect the tracing of the caller.  Conversely, if you only
         wish to debug a subroutine, you could insert a "TRACE Results"
         at the start.  Upon return, tracing will automatically be
         restored to the conditions at entry (for example, "Normal").

      7. When control reaches an internal routine, REXX puts the line
         number of the CALL instruction in the special variable SIGL
         (in the caller's variable environment).  You can use this as a
         debugging aid to determine the source of a call to a routine.

      8. An internal routine can include calls to other internal
         routines, and recursive calls to itself.



   Example

      /* Example of a recursive subroutine execution. */

         arg x
         call Factorial( x )
         say x'! = ' result
         exit

      Factorial:  procedure /* calculate factorial by */
         arg n              /* recursive invocation.  */
         if n = 0 then
            return 1
         call Factorial( n-1 )
         return result*n


   --------------------------------------------------------------------
                                    DO
   --------------------------------------------------------------------


   Purpose

      DO is the most complex REXX instruction.    You can use it to:

      *  Group instructions together and execute them as one.

      *  Execute a repetitive loop and step a control variable through
         some series of values.

      *  Execute a conditional loop that is recalculated on each itera-
         tion.

   Syntax

      >>-DO-+---------++-----------+;+--------------+END+----+-;-><
            +repetitor++conditional+ ||------------||   +name+
                                     +“-instruction++
                                                                                         [29]

      repetitor:

      >-----+-name=expri-+--------+-+--------+-+---------+-+-----><
            |            +TO-exprt+ +BY-exprb+ +FOR-exprf+ |
            +-FOREVER -------------------------------------+
            |                                              |
            +-exprr----------------------------------------+

      conditional:

      >-----+-WHILE-exprw-+--------------------------------------><
            |             |
            +-UNTIL-expru-+

   Parameters

      name        Specifies the name of a control variable, which is
                  given an initial value before the first execution of
                  the instruction list.  REXX steps the control vari-
                  able each time the loop is executed.  Name is used
                  with the following subkeywords and expressions:

                  expri - Expression for Initial value.  Specifies the
                  value for the control variable the first time through
                  the loop.

                  TO exprt - Expression for To value.  Specifies the
                  value for the control variable the last time through
                  the loop.

                  BY exprb - Expression for By value.  Specifies the
                  number to add to the control variable at the end of
                  the loop.  The default for  exprb is '1'.


                  FOR exprf - Expression for For value.  Specifies the
                  number of iterations through the loop.

      FOREVER     Executes the loop as long as a condition is satis-
                  fied.

      exprr       Specifies a whole number, which is the number of
                  times to execute the loop.
                                                                          
      conditional Specifies a conditional loop.  conditional can be one   
                  of the following:                                   
                                                                   
                  WHILE exprw - Expression for While value.  Test for
                  termination, discontinue execution of DO loop if
                  while value is not met.                   
                                                           
                  UNTIL expru - Expression for Until value.  Test for
                  termination, discontinue execution of DO loop if
                  until value is met.

      instruction Any sequence of instructions, including the more
                  complex constructions such as IF, SELECT, or the DO
                  instruction itself.
                                                                                         [30]

   Remarks

      1. Expri, exprb, exprf, exprr, and exprt can be any expression
         that resolves to a number.  Exprr and exprf are further
         restricted to result in a non-negative whole number.  

      2. Exprw (while) or expru (until) can be any expression that
         resolves to '1' or '0'.

      3. The TO, BY, and FOR subkeywords can be in any order.  REXX
         resolves them in the order they are specified.

      4. The subkeywords TO, BY, FOR, WHILE, and UNTIL are reserved
         within a DO instruction, in that they cannot name variables in
         the expression(s) but they can be used as the name of the
         control variable.  FOREVER is also reserved, if it immediately
         follows the keyword DO.


   Simple DO group

      If you specify the DO instruction without repetitor or
      conditional, it groups a number of instructions together and
      executes them as one.  This is called a simple DO group.




      /* The two instructions between DO and END are */
      /* executed if A has the value 3.              */

         if a=3 then
            do
               a=a+2
               say 'Hello!'
            end


   Simple repetitive loop

      If you do not specify repetitor, but you specify conditional, or
      if you specify repetitor as FOREVER, REXX executes the group of
      instructions until the condition is satisfied or REXX executes an
      instruction that ends the loop.  For example:

      /* This types "The total is" at least once */
         do forever
            say 'The total is'
            if random(5)=1 then leave
         end

      To specify the number of times to execute the loop use exprr,
      which must result in a whole number.  The result determines the
      number of times the loop executes.  For example:

      /* This types "Bye" seven times */
         do 7
            say 'Bye'
                                                                                         [31]
         end

      If the first token of exprr is a symbol and the second token is
      an "=", REXX expects the controlled form of repetitor.


   Controlled repetitive loop

      A controlled repetitive loop specifies a control variable, name,
      which takes an initial value from the result of expri before the
      first execution of the instruction list.  REXX steps the control
      variable by adding the result of exprb before the second and
      subsequent times that it executes the instruction list.

      REXX executes the instruction repeatedly while the end condition
      (determined by the result of exprt) is not met.  If exprb is
      positive or zero, the loop terminates when name is greater than
      exprt.

      REXX evaluates the expressions expri, exprt, and exprb once only,
      before the loop begins and it sets the control variable to its
      initial value.  The expressions must result in numbers, although
      the numbers do not have to be whole.  The default value for exprb
      is 1.  If you do not specify exprt, the loop executes
      indefinitely unless it is terminated by some other condition.



      /* Displays:  5, 4, 3, 2, 1, 0, -1 */
         do i=5 to -1 by -1
            say i
         end

      DO tests the end condition at the start of each iteration (and
      after it steps the control variable, on the second and subsequent
      iterations).  If the end condition is met immediately, DO skips
      the instruction list.

      You can alter the value of the control variable within the loop
      to affect the iteration of the loop.  Although this is usually
      considered questionable programming practice, it might be appro-
      priate in some circumstances.

      Note that the control variable is referenced by name.  For exam-
      ple, if you use the compound name "A.I" for the control variable,
      altering "I" within the loop changes the control variable.

      You can further bound a controlled loop's execution by a FOR
      phrase.  To do this, specify exprf, which must evaluate to a
      non-negative whole number.  This acts just like the repetition
      count in a simple repetitive loop, and sets a limit to the number
      of iterations around the loop if it is not terminated by some
      other condition.  Like the TO and BY expressions, REXX evaluates
      it once only, when it first executes the DO instruction and
      before it gives the control variable its initial value.  Like the
      TO condition, REXX checks the FOR count at the start of each
      iteration.  For example:

      /* Displays:  0.7, 1.3, 1.9, 2.5 */
                                                                                         [32]
         do x=0.7 to 4.9 by 0.6 for 4
            say x
         end

      In a controlled loop, you can specify the name that describes the
      control variable on the END clause.  This enables REXX to check
      the nesting of loops automatically.  REXX checks that the name
      exactly matches the name that describes the control variable in
      the DO clause (REXX ignores alphabetic case, and does not substi-
      tute compound variables while matching).  If the name does not
      match, it raises an error.  For example:

         do k=1 to 10
            ...
            ...
         end k
      /* Checks that this is the END for K loop */



   Conditional loop

      You can follow any of the forms of repetitor by a conditional
      phrase which can terminate the loop.  The conditional phrase can
      be either WHILE or UNTIL.  If you specify WHILE or UNTIL, REXX
      evaluates the expression that follows each time around the loop
      using the latest values of all variables (which must evaluate to
      either '0' or '1'), and executes the instruction list repeatedly
      either while the result is '1', or until the result is '1'.

      For a "WHILE" loop, REXX evaluates the condition before it
      executes the instruction list.  For an "UNTIL" loop, REXX evalu-
      ates the condition after it executes the instruction list -
      before it steps the control variable.

      /* Displays:  1, 3, 5 */
         do i=1 to 10 by 2 until i > 4
            say i
         end

      Note: You can also use the LEAVE or ITERATE instructions to
      modify repetitive loops.


   --------------------------------------------------------------------
                                   DROP
   --------------------------------------------------------------------


   Purpose

      Restores variables to their original uninitialized state.

   Syntax

               |--------|
      >>-DROP--“--name--+--;-------------------------------------><

   Parameter
                                                                                         [33]

      name   The name of one or more variables to drop, which can be
             one or more symbols, separated by blanks.  The symbols in
             name must be valid variable names.  The DROP instruction
             drops each variable name from the list of known variables,
             from left to right.  It is not an error to specify a name
             more than once, or to drop a variable that is not known.

   Example

      If you specify an exposed variable, the DROP instruction drops
      the variable owned by the original caller.

      j=4
      drop a x.3 x.j
      /* undefines the variables A, X.3, and X.4 */

   Example

      If you specify a variable as the stem of a compound variable (a
      symbol that contains only one period as the last character) all
      variables starting with that stem are dropped.

      drop x.
       /* undefines all variables whose names start with x. */


   --------------------------------------------------------------------
                                   EXIT
   --------------------------------------------------------------------


   Purpose

      Leaves a program unconditionally, and optionally returns a data
      string to the caller.  The program terminates immediately, even
      if an internal routine is currently executing.

   Syntax

      >>-EXIT--+------------+--;---------------------------------><
               +-expression-+

   Parameter

      expression REXX resolves the expression, and returns the
                 resulting data string back to the caller when the
                 program terminates. If you do not specify an expres-
                 sion, REXX does not pass a data string back to the
                 caller.

   Example

      j=3
      exit j*4
       /* Exits with the string '12'  */

   Remarks

                                                                                         [34]
      1. If no internal routine is active, RETURN and EXIT are identi-
         cal.

      2. When a program runs off the end without encountering a termi-
         nating instruction, REXX terminates the program and returns no
         result string.

      3. A REXX program does not distinguish between invocation as a
         command and invocation as a subroutine or function.  If the
         program was invoked via a command interface, REXX attempts to
         convert the returned value to a return code the host will
         accept.  If the conversion fails, it is considered a failure
         of the host interface.




   --------------------------------------------------------------------
                                    IF
   --------------------------------------------------------------------


   Purpose

      Conditionally executes an instruction or group of instructions.
      You can also use IF to select between two alternatives.

   Syntax

      >>-IF-expression-+-+--THEN--+-+-instruction----------------->
                       +;+        +;+

      >--+----------------------+--------------------------------><
         +-ELSE-+-+-instruction-+
                +;+

   Parameters

      expression REXX resolves the expression, which must result in '0'
                 or '1'.

                 *  When the result is '1', REXX executes the instruc-
                    tion that follows the keyword THEN.

                 *  When the result is '0' and you specify the ELSE
                    keyword, REXX executes the instruction that
                    follows.

      instruction Any instruction, including the complex constructions
                  such as DO and SELECT groups, and the IF instruction
                  itself.

   Remarks

      1. Remember that if the ELSE clause is on the same line as the
         last clause of the THEN part, you need a semicolon to termi-
         nate the clause following the THEN.

      2. A null clause is not an instruction, so putting an extra semi-
                                                                                         [35]
         colon after a THEN clause is not the same as using a dummy
         instruction (as it would be in PL/I).  Use the NOP instruction
         for this purpose.

      3. You cannot use a variable THEN within expression, because the
         keyword THEN is special, in that it need not start a clause.
         This allows REXX to terminate the expression following the IF
         by the THEN, without requiring a ";".




   Example

      if rc=0 then
         say 'Return code ok'
      else
         say 'Bad return code' rc

   Example

      The ELSE binds to the nearest IF at the same level.  Use the NOP
      instruction to eliminate errors and confusion when IF constructs
      are nested, as in the following example.

      1 IF rc != 0 THEN
      2     IF rc = 10 THEN
      3         SAY 'Bad return code' rc
      4     ELSE
      5         NOP
      6 ELSE
      7     SAY 'Return code ok'

        3:Only rc of 10 is trapped
        4:Prevents ELSE on line 6 from being associated with IF on line
          2
        6:ELSE is associated with IF on line 1


   --------------------------------------------------------------------
                                INTERPRET
   --------------------------------------------------------------------


   Purpose

      Executes instructions that have been built dynamically by
      resolving an expression (in contrast to instructions that already
      exist in the program).

   Syntax

      >>-INTERPRET--expression--;--------------------------------><

   Parameter

      expression REXX resolves the expression, and executes it just as
                 though the result was an actual line in the program,
                 bracketed by a DO; and an END;.
                                                                                         [36]

   Remarks

      1. INTERPRET allows any instructions (including the INTERPRET
         instruction) as long as they are complete.  For example, a
         string of instructions cannot contain a LEAVE or ITERATE
         instruction unless it also contains the whole repetitive
         DO...END construct.

      2. REXX ignores label clauses in the interpreted character
         string.  So if you execute a SIGNAL instruction from within an
         interpreted string, it will exit that string before starting
         the label search.

      3. REXX implies a semicolon at the end of the expression during
         execution.

   Examples

      Data='RICK'
      INTERPRET Data '= 4'
      /* Will a) build the string  "RICK = 4"       */
      /*      b) execute  "RICK = 4;"               */
      /* Thus the variable RICK will be set to '4'  */

      If you are getting results that you do not understand, you might
      find it helpful to set "TRACE R" or "TRACE I" before you execute
      the INTERPRET instruction.  For example:

      /* Small program with trace on */
      trace i
      name='Dolly'
      indirect='name'
      interpret 'say "Hello"' indirect'"!"'

      The trace shows the following:


           >>> 2 name='Dolly'
           >r>   NAME = "Dolly"
           *-* 3 indirect='name'
           >r>   INDIRECT = "name"
           *-* 4 interpret 'say "Hello"' indirect'"!'"
           >v>   INDIRECT = "name"
           >r>   RESULT =
           >r>   RC = 0
           *-* 1 say "Hello" name"!"
           >v>   NAME = "Dolly"
      Hello Dolly!
           >r>   RESULT = 0
           >v>   RESULT = 0
           *-* 5 exit 
           >r>   RESULT = 0
           >v>   RESULT = 0

      The trace shows:

      *  Lines 2 and 3 set the variables used in line 4.

                                                                                         [37]
      *  Line 4 then executes in two stages.  First, REXX builds the
         string to be interpreted using a literal string, a variable
         (indirect), and another literal string.  It then interprets
         the resulting pure character string, just as though it were
         part of the original program.  Since it is a new clause, REXX
         traces it as such (the second *-* trace flag under line 4) and
         executes it.

      *  It again concatenates a literal string to the value of a vari-
         able (name) and another literal string, and displays the final
         result:  "Hello Dolly!".

      For many purposes, you can use the VALUE built-in function
      instead of the INTERPRET instruction.  For example, you could
      replace line 4 in the last example by:

      say "Hello" value(indirect)"!"

      You need to use the INTERPRET instruction only in special cases,
      such as when you need to interpret more than one instruction at
      once, or when you need to evaluate an expression dynamically.




   --------------------------------------------------------------------
                                 ITERATE
   --------------------------------------------------------------------


   Purpose

      Alters the flow of control within a repetitive DO loop, that is,
      any DO construct other than that with a plain DO.  When REXX
      encounters the ITERATE instruction, it stops executing the
      instruction list and passes control back up to the DO clause,
      just as though it had encountered the END clause.  It then steps
      (iterates) any control variable and executes the instruction list
      again, unless the DO clause terminates the loop.

   Syntax

      >>-ITERATE--+------+--;------------------------------------><
                  +-name-+

   Parameter

      name   The name of the control variable of a currently active
             loop.  REXX terminates any active loops inside the one you
             select for iteration (as though it had encountered a LEAVE
             instruction).

             If you do not specify a name, ITERATE steps the innermost
             active repetitive loop.

             name must exactly match the symbol naming the control
             variable in the DO clause (in all respects except case).
             When REXX compares name with the name of the control vari-
             able, it does not substitute compound variables.
                                                                                         [38]

   Remarks

      1. A loop is active if it is currently executing.  If, during
         execution, the loop calls a subroutine or executes an
         INTERPRET instruction, the loop becomes inactive until the
         subroutine returns or the INTERPRET instruction completes.
         You cannot use the ITERATE instruction to step an inactive
         loop.

      2. If more than one active loop uses the same control variable,
         ITERATE selects the innermost active loop.

   Example

      /* Displays the numbers:  1, 3, 4, 5 */
         do i=1 to 5
            if i=2 then iterate
            say i
         end




   --------------------------------------------------------------------
                                  LEAVE
   --------------------------------------------------------------------


   Purpose

      Exits immediately from one or more repetitive DO loops.  A repet-
      itive DO loop is any DO construct other than one with a simple
      DO.

   Syntax

      >>-LEAVE--+------+--;--------------------------------------><
                +-name-+

   Parameter

      name   The name of the control variable of a currently active
             loop (which might be the innermost).  LEAVE terminates
             that loop and any active loops inside it, and passes
             control to the clause that follows the END that matches
             the DO clause of the selected loop.

             Name must match the control variable name on the DO
             instruction.  When the LEAVE instruction compares name
             with the name of the control variable, it does not substi-
             tute compound variables.

             If you do not specify name, LEAVE terminates the innermost
             active repetitive loop.

   Remarks

      1. The LEAVE instruction terminates execution of the group of
                                                                                         [39]
         instructions and passes control to the instruction following
         the END clause.  This is as though the END clause had been
         encountered and the DO loop had terminated normally, except
         that when the loop exits, the control variable (if any)
         contains the value it had when the LEAVE instruction was
         executed.

      2. A loop is active if it is currently executing.  If, during
         execution, the loop calls a subroutine or executes a INTERPRET
         instruction, the loop becomes inactive until the subroutine
         returns or the INTERPRET instruction completes.  The LEAVE
         instruction does not terminate an inactive loop.

      3. If more than one active loop uses the same control variable,
         LEAVE selects the innermost active loop.




   Example

      /* Displays the numbers:  1, 2, 3, 4 /*
         do i=1 to 10
           say i
           if i=4 then leave
         end


   --------------------------------------------------------------------
                                   NOP
   --------------------------------------------------------------------


   Purpose

      Acts as a dummy instruction that has no effect.  It can be useful
      as the target of a THEN or ELSE clause.

   Syntax

      >>-NOP---;-------------------------------------------------><

   Example

      select
        when a=b then nop         /* Does nothing */
        when a>b then say 'A > B'
        otherwise     say 'A < B'
      end

      Note: Putting an extra semicolon instead of the NOP instruction
      merely inserts a null clause, which is ignored.  The second WHEN
      clause would then immediately follow the THEN, and REXX would
      raise a syntax error.    NOP is a true instruction, however, and
      is therefore a valid target for the THEN clause.


                                                                                         [40]
   --------------------------------------------------------------------
                                  PARSE
   --------------------------------------------------------------------


   Purpose

      Assigns data (from various sources) to one or more variables
      according to the parsing rules.  See "Parsing" on page 95.

   Syntax

      >>-PARSE--+-------+-+--ARG------------------------+--------->
                +-UPPER-+ +--PULL-----------------------+
                          +--VALUE--+------------+-WITH-+
                          |         +-expression-+      |
                          +--VAR-name-------------------+

      >---+----------+--;----------------------------------------><
          +-template-+

   Parameters

      UPPER    Translates the character strings to upper case.  Other-
               wise no translation takes place during the parsing.

      template A list of symbols separated by blanks and/or patterns.

               If you do not specify template, PARSE does not set any
               variables, but takes action to get the data ready for
               parsing if necessary.  For example, PARSE LINEIN and
               PARSE PULL remove a line from the appropriate character
               stream or data queue, PARSE VALUE resolves the expres-
               sion, and PARSE VAR checks the variable to ensure that
               it has a value.

      ARG      Parses the string(s) passed to the program, subroutine,
               or function as the input arguments.  

               To retrieve or check the argument string(s) to a REXX
               program, use the ARG built-in function.

               template can refer to more than one string only if you
               specify PARSE ARG.  The other options process a single
               string and so you cannot include the comma as a special
               character in the template (except within a literal
               string pattern).


      PULL     Parses the next string from the external data queue.  If
               the external data queue is empty, PARSE PULL reads lines
               from the default character input stream.  The program
               pauses if necessary until a line is complete.

               To add strings to the head or tail of the queue, use the
               PUSH and QUEUE instructions respectively.  Other
               programs can also alter the external data queue, so it
               can be used as a means of communication between these
               programs and REXX programs.    See the PULL instruction
               on page 43.
                                                                                         [41]

               To find the number of lines currently in the data queue,
               use the QUEUED built-in function.


      VALUE    Resolves expression, and parses the resulting character
               string.  If you do not specify an expression, PARSE
               VALUE uses the null string.

 
      VAR name Parses the value of the variable specified by name.  The
               name must be a symbol that is valid as a variable name
               (that is, it cannot start with a period or a digit).

               The variable itself is not changed unless it appears in
               the template.  For example, this instruction removes the
               first word from STRING, puts it in the variable WORD1,
               and assigns the remainder back to STRING:

               parse var string word1 string

               Similarly, the next instruction translates the data from
               STRING to upper case before parsing:

               parse upper var string word1 string


   --------------------------------------------------------------------
                                PROCEDURE
   --------------------------------------------------------------------


   Purpose

      Protects all the existing variables from being changed by a
      subroutine or function by making them unknown to any instructions
      that follow.  This lets you create new variables in a subroutine
      or function, even if they have the same names as variables in the
      main program.

   Syntax

      >>-PROCEDURE--+------------------+---;---------------------><
                    |         |------| |
                    +-EXPOSE--“-name-+-+

   Parameters

      EXPOSE Exposes the specified variables to the caller, so that any
             references to them (including setting and dropping them)
             refer to the variables environment owned by the caller.
             This lets you share variables across the main program and
             functions or subroutines.  Any changes made to the speci-
             fied variables remain in effect, even on RETURN from the
             routine.

      name   One or more symbols separated by blanks.  The symbols must
             be valid variable names, and are exposed in sequence from
             left to right.  It is not an error to specify a name more
                                                                                         [42]
             than once, or to specify a name that has not been used as
             a variable by the caller.

   Remarks

      1. When the RETURN instruction executes, REXX restores the
         original variables environment, and drops any variables used
         in the routine that were not exposed.

      2. The PROCEDURE instruction must be the first instruction
         following the label.

      3. You can only use PROCEDURE with a subroutine or function.

      4. A routine need not include a PROCEDURE instruction, in which
         case the variables it manipulates are those "owned" by the
         caller.

      5. You can expose variables through several generations of
         routines, if desired, by ensuring that they are included
         (exposed) on all intermediate PROCEDURE instructions.

      6. See the CALL instruction on page 26 and the function descrip-
         tions for details and examples of how routines are invoked.


   Example

      /* This is the main program */
         j="P";  x.j='a'
         call Someproc
         say j k w       /* displays "0 9 W" */
         exit

      /* This is a subroutine */
      Someproc: procedure expose j k x.j
         say j k x.j   /* displays "P K a"     */
         j=0; k=9; w=3 /* "W" is not exposed   */
         say j k x.j   /* displays "0 K X.0"     */
         k=9; w=3      /* "W" is not exposed   */
         return

   Example

      To expose an entire collection of compound variables, specify
      their stem in name.  (The stem is that part of the name up to and
      including the first period.) The variables are exposed for all
      operations.

      /*  This exposes "J", "K", and all variables  */
      /*    whose name starts with "A." or "B."     */
      procedure expose j k a. b.
      a.1='9'   /* This sets "A.1" in the caller's  */
                /*   environment, even if it did    */
                /*   not previously exist.          */


                                                                                         [43]
   --------------------------------------------------------------------
                                   PULL
   --------------------------------------------------------------------


   Purpose

      Reads a string from the external data queue.  PULL is just a
      shorter form of the instruction PARSE UPPER PULL.

   Syntax

      >>-PULL--+----------+--;-----------------------------------><
               +-template-+

   Parameter

      template A list of symbols separated by blanks and/or patterns.

               The PULL instruction will only read one string, so you
               cannot include the comma ( , ) in the template (except
               within a literal string pattern).

   Remarks

      1. The current head-of-queue is read as one string.  If you do
         not specify a template, REXX takes no further action (effec-
         tively discarding the string).  Otherwise, REXX translates the
         string to upper case and parses it into variables according to
         the parsing rules.  See "Parsing" on page 95.  If you do not
         want REXX to translate the string to upper case, use the PARSE
         instruction.

      2. If the external data queue is empty, lines are read from the
         default character input stream, and the program pauses if
         necessary until a line is complete.

      3. To find the number of lines currently in the external data
         queue, use the QUEUED built-in function.

   Example

      This example uses the dummy placeholder "." on the template to
      isolate the first word the user types, ready for comparison.

      say 'Erase the file?  Answer Yes or No:'
      pull answer .
      if answer='YES'  then Erase oldfile


   --------------------------------------------------------------------
                                   PUSH
   --------------------------------------------------------------------


   Purpose

      Stacks the string resulting from the evaluation of the expression
      LIFO (Last-In, First-Out) onto the external data queue.  If you
      do not specify an expression, PUSH stacks a null string.

                                                                                         [44]
   Syntax

      >>-PUSH--+------------+--;---------------------------------><
               +-expression-+

   Example

      a='Time'
      push           /* Stacks a null line   */
      push a 7 8     /* Stacks "Time 7 8"    */

   Remarks

      To find the number of lines currently in the external data queue,
      use the QUEUED built-in function.



   --------------------------------------------------------------------
                                  QUEUE
   --------------------------------------------------------------------


   Purpose

      Appends the string resulting from the resolution of the expres-
      sion onto the tail of the external data queue.  That is, the
      string is added FIFO (First In, First Out).  If you do not
      specify an expression, QUEUE stacks a null string.

   Syntax

      >>-QUEUE--+------------+--;--------------------------------><
                +-expression-+

   Example

      a='Me'
      queue a 'too'  /* Queues "Me too"    */
      queue          /* Queues a null line */

   Remarks

      To find the number of lines currently in the external data queue,
      use the QUEUED built-in function.


   --------------------------------------------------------------------
                                  RETURN
   --------------------------------------------------------------------


   Purpose

      Returns control (and possibly a result) from a REXX program or
      internal routine to the point of its invocation.

   Syntax

                                                                                         [45]
      >>-RETURN--+------------+--;-------------------------------><
                 +-expression-+

   Remarks

      1. The internal routine can be either a subroutine (see the CALL
         instruction), or a function.  If no internal routine (subrou-
         tine or function) is active, RETURN is identical to EXIT.

      2. When REXX encounters the RETURN instruction while a subroutine
         is executing, it:

         *  Evaluates the expression (if any)

         *  Returns control to the caller

         *  Sets the special variable RESULT to the value of the
            expression.

         If you do not specify an expression, RETURN: uninitializes the
         special variable RESULT and restores the various settings it
         saved at the time it encountered the CALL instruction.

      3. When REXX encounters the RETURN instruction while a function
         is executing, it:

         *  Evaluates the expression (you must specify an expression
            for a function)

         *  Returns control to the caller

         *  Sets the special variable RESULT to the value of the
            expression.  The result of the expression is used in the
            original expression at the point where the function was
            invoked.

      4. If a PROCEDURE instruction executes within the internal
         routine, it drops all variables of the current generation (and
         exposes the previous generation), after it resolves the
         expression and before the result is used or assigned to the
         special variable RESULT.



   --------------------------------------------------------------------
                                   SAY
   --------------------------------------------------------------------


   Purpose

      Writes the result of resolving the expression to the output
      stream.  It usually displays the result to the user, but the
      output destination can vary.  The result of expression can be any
      length.

   Syntax

      >>-SAY--+------------+--;----------------------------------><
                                                                                         [46]
              +-expression-+

   Remarks

      REXX writes the result of resolving the expression from the
      program via the default character output stream.  The line is
      formatted by the operating system and the hardware.  If you do
      not specify an expression, it writes the null string.


   Example

      number=75
      say number 'multiplied by 3 =>' number * 3
      /* Types:       "75 multiplied by 3 => 225" */



   --------------------------------------------------------------------
                                  SELECT
   --------------------------------------------------------------------


   Purpose

      Conditionally executes one of any number of alternative instruc-
      tions.

   Syntax

                  |------------------------------------------|
      >>-SELECT-;-“-WHEN-expression-+-+-THEN-+-+-instruction-+---->
                                    +;+      +;+

      >--+------------------------------------+---END;-----------><
         +-OTHERWISE-+-+-+-----------------+--+
                     +;+ | |-------------| |
                         +-“-instruction-+-+

   Parameters

      instruction Any valid instruction.  This may be a complex
                  instruction, such a DO..END block.

   Remarks

      1. REXX resolves each expression that follows a WHEN in turn.
         The expression must result in '0' or '1'.

         *  If the result is '1', REXX executes the instruction that
            follows the associated THEN (which can be a complex
            instruction such as IF, DO or SELECT) after which it passes
            control directly to the END.

         *  If the result is '0', REXX passes control to the next WHEN
            clause.

            If none of the WHEN expressions result in '1', REXX passes
            control to the instruction (if any) following OTHERWISE.
                                                                                         [47]
            If it does not find an OTHERWISE, it raises an error.

      2. A null clause is not an instruction, so putting an extra semi-
         colon after a THEN clause is not the same as using a dummy
         instruction (as it would be in PL/I).  Use the NOP instruction
         for this purpose.

      3. You cannot use a variable THEN within expression, because the
         keyword THEN is special, in that it need not start a clause.
         This allows REXX to terminate the expression on the WHEN
         clause by the THEN, without requiring a ";"nwhich is consis-
         tent with the treatment of THEN following an IF clause.



   Example

      'STATE' logfile

      select
         when rc=0 then
            do
               'PRINT' logfile
               'ERASE' logfile
               say 'File' logfile 'printed and erased'
            end
         when rc=16 then
            say logfile  'does not exist'
         otherwise
            say 'Return code "'rc'" from STATE'
            exit rc
      end /* Select */



   --------------------------------------------------------------------
                                  SIGNAL
   --------------------------------------------------------------------


   Purpose

      Causes an abnormal change in the flow of control, or controls
      condition trapping.

   Syntax

      >>-SIGNAL--+--labelname----------------------+--;----------><
                 +-ON--condition-+---------+-------+
                 |               +--label--+       |
                 +-OFF-condition-------------------+

   Parameters

      label      A single symbol or literal string, which is taken as a
                 constant. If no label is specified, the conditionname will
                 act as the labelname.

      condition  A single symbol or literal string, which is taken as a
                                                                                         [48]
                 condition keyword.  For a discussion of conditions or
                 traps, see "Condition Traps" on page 108.


      To change the flow of control:

      REXX takes the label name either directly from labelname, or from
      the result of resolving the expression that follows VALUE.  You
      can omit VALUE if the expression does not begin with a symbol or
      a literal string (that is, if it starts with a special character,
      such as an operator or parenthesis).

      REXX then terminates all active pending DO loops, DO groups, IF
      constructs, SELECT constructs, and INTERPRET instructions in the
      current routine, and they cannot be reactivated.  Control then
      passes to the first label in the program that matches labelname,
      as though the search had started from the top of the program.
      The labelname must match the label exactly, unless the label name
      is a symbol, in which case REXX ignores alphabetic case.

      signal help;  /* Go to label HELP below */
        ...
        ...
      Help:
         say 'News'

      To trap exceptions:




      Specify ON to enable a particular exception trap, or OFF to
      disable a trap.  The default is OFF.  When exception trapping is
      OFF, and one of the following conditions occur, no special action
      is taken.  When exception trapping is ON and the corresponding
      condition occurs, the current instruction terminates and the
      SIGNAL instruction executes automatically.  Control passes to the
      first label in the program that matches the condition.

      The conditions are:

      NOVALUE  The program used an uninitialized variable.  The vari-
               able is used as:

               *  A term in an expression

               *  The name following the VAR subkeyword of the PARSE
                  instruction

               *  An unassigned variable pattern in a parsing template

      Once SIGNAL traps an event, its corresponding condition is
      disabled (before the SIGNAL takes place), and you must use a new
      SIGNAL ON instruction to re-enable it.  For example, if REXX
      cannot find the required label, it takes a normal syntax error
      exit, which traces the name of that label and the clause in which
      the event occurred.


                                                                                         [49]


   Remarks

      1. REXX saves the conditions on entry to a subroutine and
         restores them when it encounters the RETURN instruction.  This
         means that you can use SIGNAL ON and SIGNAL OFF in a subrou-
         tine without affecting the conditions set up by the caller.
         See the CALL instruction on page 26.

      2. Whenever an event occurs that corresponds to an enabled condi-
         tion, the current instruction terminates and the SIGNAL
         instruction executes immediately.  This means that if an event
         occurs during an instruction, the instruction might not
         complete execution.  For example, if you specify SIGNAL ON
         NOVALUE and an error occurs during an expression
         resolution in an assignment,  the assignment will not be made.


   The special variable SIGL

      REXX stores the program line number of the SIGNAL instruction
      that caused a jump in the special variable SIGL.  


   --------------------------------------------------------------------
                                  TRACE
   --------------------------------------------------------------------


   Purpose

      Controls the tracing of execution of a REXX program, and is
      primarily used for debugging.  Its syntax is more concise than
      other REXX instructions, since it is commonly typed manually
      during interactive tracing.

   Syntax

      >>-TRACE--+-----------------------+--------;---------------><
                +--tracesetting---------+

   Parameters

      tracesetting A symbol or literal string which is taken as a
                   constant.  The tracesetting specifies what type of
                   tracing to perform, and whether interactive tracing
                   is on or off.
                  
   Remarks

      The trace setting is taken from the literal tracesetting,


   Prefix Options:

      The setting may start with one "?" characters, followed by the one of the 
      following alphabetic tracesettings.  The "?" toggles the interactive trace
      setting.
                                                                                         [50]

   Alphabetic Options:

      Only the first character of an alphabetic setting is significant;
      all other letters are ignored.  The alphabetic settings are:
 
      N  (Normal) Traces nothing except host commands resulting in
         failure.  These are traced (after execution) together with the
         return code from the command.  This is the default.

      R  (Results) Traces all clauses before execution, together with
         the final result of any expression evaluated.  Values assigned
         during PULL, ARG, and PARSE instructions are also displayed.
         We recommend this setting for general debugging.

      L  (Labels) as "N" except that all terms and intermediate
         results during expression evaluation (and substituted names)
         are also traced.
    
      I  (Intermediates) as "R" except that all terms and intermediate
         results during expression evaluation (and substituted names)
         are also traced.
 
   Example

      trace ?r
      /* Interactive tracing is switched on if it was */
      /*   off before, and line by line, results      */
      /*   of expressions will now be traced          */

   Remarks

      1. If you do not specify a trace setting, or you specify the null
         string, tracing is reset to its initial setting: "Normal" and
         "Interactive tracing OFF".

      3. The trace setting is automatically saved across subroutine and
         internal function calls.  See the CALL instruction on page 26.


   Interactive tracing and debugging

      The "?" prefix on the trace setting is used to control interac-
      tive tracing.  During normal execution, executing a TRACE
      instruction with a "?" setting prefix causes interactive tracing
      to be switched on.  While tracing interactively, interpretation
      will pause after most clauses that are traced; and TRACE instruc-
      tions in the program are ignored (this is so you are not taken
      out of interactive tracing unexpectedly).  The state of interac-
      tive tracing (that is, whether it is on or off) is saved and
      restored across internal routine calls.
      While in interactive trace you are given the possibility 
      to execute immediate Rexx statements, 
      to set breakpoints, 
      to remove breakpoints, 
      to list the source, 
      to resume execution on a different statement than the logical next one.

      As an example, the instruction:  "TRACE ?Results" will make the
      language processor pause for input after executing any host
      command that returns a nonzero return code.

      Interactive tracing can be switched off by executing a TRACE
      instruction without a prefix "?" during an interactive pause, or by
      executing "Off".  
                                                                                         [51]

   The format of TRACE output

      TRACE displays every clause that it traces. The first clause
      traced on any line will be preceded by its line number.

      All lines displayed during tracing have a three character prefix
      to identify the type of data being traced.  The prefixes are:

      *-*    Identifies the source of a single clause, that is, the
             data actually in the program.

      >r>    Identifies the result of an expression (for TRACE
             Results), or the value assigned to a variable during pars-
             ing, or the value returned from a call to a subroutine or
             function.

      >v>    The string traced is the contents of a variable.

      >l>    The string traced is label.


      Notes:

      1. When a loop is being traced, the DO clause itself is traced on
         every iteration of the loop.





                                Chapter 9.
                                Functions




      A function is a call to an internal or external routine.  Func-
      tions have a name, one or more arguments (though arguments are
      not always required), and return a single result string.

      Functions are of the form:

      >>---symbol(----+------------------+-)---------------------><
                      | |-------,------| |
                      +-“+------------++-+
                         +-expression-+

      REXX takes the symbol as a constant. You can include a function 
      in an expression anywhere that a literal string or symbol is valid.

      The expressions between the parentheses are the arguments to the
      function.  Each argument can include further function calls.  The
      value a function returns depends on the argument(s).

                                                                                         [52]

   Types of Functions

      You can call the following types of routines as functions:

      Internal A routine that resides in the same file as the program
               that uses it is called an internal routine, or function.
               An internal function starts at a label in the program.
               REXX saves the current state of interpretation, so that
               later it can return to the point of invocation to resume
               execution.  REXX also saves other internal values (TRACE
               settings, and so forth).  See the CALL instruction on 
               page 26.  If you call an internal routine
               as a function, you must specify an expression on any
               RETURN instruction you execute to return from the
               routine.  This is not necessary if you call an internal
               routine as a subroutine.

      Built-in REXX contains a useful set of built-in functions.  See
               "Built-In Functions" on page 53.

      External A routine that resides in a separate file from the
               program that uses it is called an external routine, or
               function.  You can write these external routines in any
               language that supports the system dependent interfaces
               from which REXX invokes the function (including REXX).
               This means you can invoke a REXX program as a function,
               and pass it more than one argument string.  Since you
               call the program as a function, it must return data to
               the caller.

               You can use the ARG or PARSE ARG instructions to retrieve
               the argument string(s), or the ARG built-in function.

               Calling an external routine as a function is similar to
               calling an internal routine.  However, the external
               routine protects its variables from the caller's vari-
               ables and its internal values start with their defaults
               rather than inheriting the caller's internal values.
               Another difference is that you can use the EXIT instruc-
               tion to return from the routine.

      The function calling mechanism is the same as the mechanism used
      for subroutines.  However, a subroutine need not return a result,
      but a function must return a result.


   Search order

      REXX searches for functions in this order:

      1. Internal labels

      2. Built-in functions

      3. External functions



                                                                                         [53]

   Built-In Functions

      REXX contains many useful built-in functions. These functions
      perform various searching, processing, comparison, and conversion
      operations for both text and numbers.  Other built-in functions
      provide formatting capabilities and arithmetic calculations.

      Notes:

      *  You can provide a null string where a string is referenced.

      *  Pad characters must be exactly one character long.

                        Table 10. Built-in Functions


                  Function             Description

                 ABBREV( )    Specifies which abbreviations
                              the program can use
                 ABS( )       Returns the absolute value of
                              a number
                              exclusive ORed together
                 B2X( )       Converts a binary string to a
                              hexadecimal value
                 CHARIN( )    Returns a string of characters
                              read from a character input
                              stream
                 CHAROUT( )   Writes a string to a character
                              output stream
                 CHARS( )     Returns the total number of
                              characters remaining in a
                              character input stream
                 COMPARE( )   Compares two strings and finds
                              the position of the first
                              character in the first string
                              that does not match the second
                              string
                 COPIES( )    Returns a number of copies of
                              a string, directly concate-
                              nated
                 C2X( )       Converts an ASCII character to
                              its value in hexadecimal
                 DATATYPE( )  Tests REXX data types such as
                              numeric, alphanumeric
                 DATE( )      Returns the local date in many
                              different formats
                 DELSTR( )    Deletes a substring from a
                              string
                 FORMAT( )    Rounds and formats a number
                 INSERT( )    Inserts a string into another
                              string
                 LASTPOS( )   Finds the position of a
                              substring in another string,
                              by scanning backwards
                 LEFT( )      Returns characters from the
                              left side of a string
                 LENGTH( )    Returns the length of a string
                                                                                         [54]
                 LINEIN( )    Returns a line from a
                              character input stream
                 LINEOUT( )   Writes a string to a character
                              output stream
                 LINES( )     Returns the total number of
                              complete lines remaining in a
                              character input stream
                 OVERLAY( )   Overlays one string onto
                              another string
                 POS( )       Returns the position of a
                              substring in another string
                 QUEUED( )    Returns the number of lines
                              remaining in the external data
                              queue
                 RANDOM( )    Returns a number chosen at
                              random from a range of numbers
                 REVERSE( )   Reverses the order of charac-
                              ters in a string
                 RIGHT( )     Returns characters from the
                              right side of a string
                 SIGN( )      Tests a number for >, <, or =
                              to zero after rounding
                 STREAM( )    Returns a string that
                              describes the state of, or
                              result of an operation upon, a
                              character stream
                 STRIP( )     Removes leading or trailing
                              characters from string
                 SUBSTR( )    Returns a substring of a
                              string, by character
                 TIME( )      Returns the local time in many
                              different formats
                 TRANSLATE( ) Translates characters in a
                              string to other characters, or
                              reorders characters in a
                              string
                 TRUNC( )     Returns the integer part of a
                              number
                 VALUE( )     Returns the value of a symbol
                 VERIFY( )    Verifies whether a character
                              string is, or is not, a member
                              of a given character set
                 WORD( )      Returns the nth blank-
                              delimited word in string
                 WORDS( )     Returns the number of blank-
                              delimited words in a string
                 XRANGE( )    Returns a string of one byte
                              character representations
                              within a range of characters
                 X2B( )       Converts a value in
                              hexadecimal to a binary string
                 X2C( )       Converts a value in
                              hexadecimal to an ASCII char-
                              acter



                                                                                         [55]
   --------------------------------------------------------------------
                                  ABBREV
   --------------------------------------------------------------------


   Purpose

      Specifies which abbreviations the program will accept from the
      user.

   Syntax

      >>-ABBREV(information,info-+---------+-)-------------------><
                                 +-,length-+

   Parameters

      information The keyword in full

      info        The user's answer

      length      The minimum number of characters in the user's
                  answer.  The default is the the length of info.
                  Length must be a nonnegative whole number.

                  A null string will always match if you use a length
                  of 0 (or the default).  This lets you select a
                  default keyword automatically.

   Remarks

      Returns 1 (true) if info is at least length characters long and
      all the characters of info match the corresponding characters of
      information.  Otherwise, returns 0 (false).

   Examples

      ABBREV('Change','Cha')    @  1
      ABBREV('CHANGE','Cha')    @  0
      ABBREV('CHANGE','Cha',4)  @  0
      ABBREV('CHANGE','CHE')    @  0
      ABBREV('CHANGE','')       @  1
      ABBREV('CHANGE','',1)     @  0


   Example

      1 say 'Enter option:'
      2 pull option .
      3 select
      4    when abbrev('OPEN',option) then ...
      5    when abbrev('CLOSE',option) then ...
      6    when abbrev('PRINT',option) then ...
      7       ...
      8    otherwise nop;
      9 end;

        4:Match on 'OPEN', 'OPE', 'OP', or 'O'
        5:Match on 'CLOSE', 'CLOS', 'CLO', 'CL', or 'C'
        6:Match on 'PRINT', 'PRIN', 'PRI', 'PR', or 'P'

                                                                                         [56]
   See Also

      COMPARE( )  Compares two strings

      DATATYPE( ) Checks that characters in a string are valid
                  according to some data type.

      VERIFY( )   Verifies whether a character string is, or is not,
                  part of a character set


   --------------------------------------------------------------------
                                   ABS
   --------------------------------------------------------------------


   Purpose

      Returns the absolute value of a number.  The result has no sign
      and is formatted according to the current NUMERIC instruction
      settings.

   Syntax

      >>-ABS(number)---------------------------------------------><

   Parameter

      number The number to evaluate

   Examples

      ABS('123.45')       @  123.45
      ABS(' -0.333')      @  0.333
      ABS('-1.0E1')       @  10      

   See Also

      SIGN( )     Tests a number for <, >, or = to zero after rounding



   --------------------------------------------------------------------
                                   B2X
   --------------------------------------------------------------------


   Purpose

      Converts a binary string to a hexadecimal string.

   Syntax

      >>-B2X(string)---------------------------------------------><

   Parameters

      string The string to convert, which can be any length.  If string
             is a null string, B2X returns a null string.
                                                                                         [57]

   Remarks

      The returned string uses uppercase alphabetics for the values
      A-F, and does not include any blanks.

      You can optionally add blanks between groups of 8 (byte) or 4
      (nibble) digits (not leading or trailing) to aid readability;
      they are ignored.

      If necessary, B2X pads string with up to three leading zeros to
      make a multiple of four binary digits.

   Examples

      B2X('1010010')         @  '52'x
      B2X('01010010')        @  '52'x
      B2X('0101 0010')       @  '52'x
      B2X('0101 0010 1111')  @  '52F'x

   See Also

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      X2B( )      Converts a hexadecimal value to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character




   --------------------------------------------------------------------
                                  CHARIN
   --------------------------------------------------------------------


   Purpose

      Returns a string of characters read from a character input
      stream.

   Syntax

      >>-CHARIN(-+------+-+------------------------+--)----------><
                 +-name-+ +-,-+-------++---------+-+
                              +-start-++-,length-+

   Parameters

      name   The file name, which can be any system file.  The file
             name can include drive and path specifications.  If you
             omit name, CHARIN reads characters from the default input
             stream.

      start  The explicit read position for the read to start.  start
             must be positive and within the bounds of the stream.  A
             value of 1 specifies the first character in the stream.
             The default is the current read position.  When CHARIN
                                                                                         [58]
             completes the read, it increases the read position by the
             number of characters read.

             For persistent streams (for example, files and objects),
             REXX maintains a read position for each stream.  Any read
             from the stream starts at the position by the number of
             characters read.  You cannot specify a read position for a
             transient stream; for example, data sent or received over
             a serial interface.

      length The number of characters in the string.  The default is 1.
             If you specify a length of 0, REXX sets the read position
             to the value of start, but does not read any characters
             and returns the null string.

             If there are fewer than length characters available,
             program execution stops until sufficient characters do
             become available.  If, however, it is impossible for those
             characters to become available, CHARIN returns with fewer
             than the requested number of characters.


   Examples

      1 CHARIN(infile,1,3)  @  'ABC'
      2 CHARIN(infile,1,0)  @  ''
      3 CHARIN(infile)      @  'A
      4 CHARIN(infile,,2)   @  'BC'
      5 CHARIN( )           @  'a'
      6 CHARIN(,,3)         @  'bcd'

        1:Reads characters 1 to 3
        2:Returns to start
        3:Reads 1 character
        4:Reads 2 more characters
        5:Uses the default stream
        6:Reads 3 more characters

   See Also

      CHAROUT( )  Writes a string to a character output stream

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream


                                                                                         [59]
   --------------------------------------------------------------------
                                 CHAROUT
   --------------------------------------------------------------------


   Purpose

      Writes a string of characters to a character output stream.

   Syntax

      >>-CHAROUT(-+------+-+------------------------+--)---------><
                  +-name-+ +-,-+-------++---------+-+
                               +-start-++-,length-+

   Parameters

      name   The name of the output device, which is usually a file
             name.  The file name can include drive and path specifica-
             tions.  If you omit name, REXX writes the character string
             to the default output stream.

      string The string to write.  You can specify the null string, in
             which case REXX does not write any characters to the
             stream and always returns 0.  You can omit this argument
             for persistent streams.  In this case, CHAROUT sets the
             write position to the value of start, does not write any
             characters to the stream, and returns 0.

      start  The explicit position for the write to start.  The start
             value must be positive and within the bounds of the
             stream, although it can specify the character position
             immediately after the end of the stream.  A value of 1
             specifies the first character in the stream.  The default
             is to start at the current write position.

   Remarks

      For persistent streams, CHAROUT maintains a write position for
      each stream.  When CHAROUT completes the write, it increases the
      write position by the number of characters written.  The initial
      write position is the end of the stream, so that calls to CHAROUT
      normally append to the end of the stream.  (Unless the stream was
      opened using the STREAM() function.)

      If you do not specify a start position or a string, CHAROUT sets
      the write position to the end of the stream, closes the file, and
      returns 0.

      The program stops executing until the output operation is effec-
      tively complete.  If, however, CHAROUT cannot write all the char-
      acters, it returns with the number of characters that could not
      be written (the residual count).


   Examples

      1 CHAROUT(outfile,'At')    @ 0
      2 CHAROUT(outfile,'At',4)  @ 0
      3 CHAROUT(outfile,,5)      @ 0
      4 CHAROUT('PRN','At')      @ 0
      5 CHAROUT('LPT1')          @ 0
                                                                                         [60]
      6 CHAROUT(,'At')           @ 0
      7 CHAROUT(,'Think')        @ 2

        1:Indicates a normal return
        2:Indicates a normal return
        3:Sets current file position to character 5
        4:Writes the string 'At' to the default print device (PRN)
        5:Writes the string 'At' to printer LPT1
        6:Indicates a normal return
        7:Indicates 2 characters left

   Examples

      This routine is best called as a subroutine.  The residual count
      is then available in the special variable RESULT.

      Call CHAROUT(outfile, 'Think')
      Call CHAROUT(outfile, 'At',5)
      Call CHAROUT(outfile)

   See Also

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream


   --------------------------------------------------------------------
                                  CHARS
   --------------------------------------------------------------------


   Purpose

      Returns the total number of characters remaining in a character
      input stream.

   Syntax

      >>-CHARS(-+------+-)---------------------------------------><
                +-name-+

   Parameter

      name   The file name, which can be any system file name,
             including specific device names.  If you omit name, CHARS
             returns the number of characters available in the default
                                                                                         [61]
             input stream.

   Remarks

      The count includes any line separator characters.  For persistent
      streams (for example, files), the count includes characters from
      the current read position.

      If CHARS cannot determine the count accurately or efficiently, it
      might return 1 or more for any nonzero result.

   Examples

      CHARS('c:\config.sys')  @  1381
      CHARS(nonfile)          @  0
      CHARS( )                @  12

   See Also

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream


   --------------------------------------------------------------------
                                 COMPARE
   --------------------------------------------------------------------


   Purpose

      Compares two strings and finds the position of the first
      character in the first string that does not match the second
      string.

   Syntax

      >>-ABBREV(string1,string2-+------+-)-----------------------><
                                +-,pad-+

   Parameters

      string1  The first string

      string2  The second string

      pad      The pad character to use to pad the shorter string on
               the right.  The default is a blank.
                                                                                         [62]

   Remarks

      Returns 0 if string1 and string2 are identical.  If they are not,
      COMPARE returns a positive number that indicates the position of
      the first character that is not the same in both.

   Examples

      COMPARE('look','look')     @  0
      COMPARE('look','like')     @  2
      COMPARE('at ','at')        @  0
      COMPARE('at ','at',' ')    @  0
      COMPARE('at ','at','x')    @  3
      COMPARE('at-- ','at','-')  @  5

   See Also

      ABBREV( )   Specifies which abbreviations the program will accept

      DATATYPE( ) Checks that characters in a string are valid
                  according to some data type.

      VERIFY( )   Verifies whether a character string is, or is not,
                  part of a character set





   --------------------------------------------------------------------
                                  COPIES
   --------------------------------------------------------------------


   Purpose

      Produces a number of copies of a string, directly concatenated.

   Syntax

      >>-COPIES(string,n)----------------------------------------><

   Parameters

      string The string to copy

      n      The number of copies, which must be a non-negative whole
             number.

   Examples

      COPIES('xyz',3)     @  'xyzxyzxyz'
      COPIES('dxv',0)     @  ''

   See Also

      SUBSTR( )   Returns a substring of a string, by character

                                                                                         [63]
   --------------------------------------------------------------------
                                  CONTAINS
   --------------------------------------------------------------------


   Purpose

      Looks up if a compound variable contains a given value. If so returns the
      compound's tail (the "index"), if absent returns "0"

   Syntax

      >>-CONTAINS(string,head)----------------------------------------><

   Parameters

      string The value to look for

      head   The head of the compound variable including the point.

   Examples

      CONTAINS(123,"TBL.") @  0 if no TBL.x has value 123
      CONTAINS(123,"TBL.") @  7 if TBL.7 has value 123



   --------------------------------------------------------------------
                                   C2X
   --------------------------------------------------------------------


   Purpose

      Converts character to hexadecimal (unpacks).

   Syntax

      >>-C2X(string)---------------------------------------------><

   Parameter

      string The string to convert, which can be any length

   Remarks

      The returned string uses uppercase alphabetics for the values
      A-F, and does not include any blanks.

   Examples

      C2X('JKL')          @  '4A4B4C'
      C2X('1234'x)        @  '1234'

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      X2B( )      Converts a hexadecimal value to a binary string

      X2C( )      Converts a value in hexadecimal to an ASCII character



   --------------------------------------------------------------------
                                 DATATYPE
   --------------------------------------------------------------------


   Purpose

      Checks that data is valid.  This is useful to check data before
      attempting to do arithmetic on data entered from the keyboard.

   Syntax

      >>-DATATYPE(string-+-------+-)-----------------------------><
                         +-,type-+

   Parameters

      string The data to check.  Returns NUM if string is a valid REXX
             number (any format).  Otherwise, it returns the word CHAR.

                                                                                         [64]
      type   The type of data to match.  Returns 1 if string matches
             the type, or 0 otherwise.  If string is null, DATATYPE
             returns 0 (except when type is "X", which returns 1 for a
             null string).  The options are:

             A  (Alphanumeric) Returns 1 if string only contains char-
                acters from the ranges "a-z", "A-Z", and "0-9".

             B  (Bits) Returns 1 if string only contains the characters
                "0" and/or "1".

             L  (Lower case) Returns 1 if string only contains charac-
                ters from the range "a-z".

             M  (Mixed case) Returns 1 if string only contains charac-
                ters from the ranges "a-z" and "A-Z".

             N  (Number) Returns 1 if string is a valid REXX number.

             S  (Symbol) Returns 1 if string only contains characters
                that are valid in REXX symbols.    Lower case
                alphabetics are permitted.

             U  (Upper case) Returns 1 if string only contains charac-
                ters from the range "A-Z".

             W  (Whole number) Returns 1 if string is a REXX whole
                number under the current setting of the NUMERIC DIGITS
                instruction.

             X  (heXadecimal) Returns 1 if string only contains charac-
                ters from the ranges "a-f", "A-F", "0-9", and blank (so
                long as blanks only appear between pairs of hexadecimal
                characters, as usual.) Also returns 1 if string is a
                null string, which is a valid hexadecimal string.



   Examples

      DATATYPE(' 23 ')       @  'NUM'
      DATATYPE(' ')          @  'CHAR'
      DATATYPE('123*')       @  'CHAR'
      DATATYPE('Minx','L')   @  0
      DATATYPE('Fred','M')   @  1
      DATATYPE('','M')       @  0
      DATATYPE('12.3','N')   @  1
      DATATYPE('$10k','S')   @  1
      DATATYPE('12','W')     @  1
      DATATYPE('12.3','W')   @  0
      DATATYPE('CF3A','X')   @  1
      DATATYPE('CF 3A','X')  @  1

   See Also

      COMPARE( )  Compares two strings

      TRANSLATE( )Translates characters in a string

                                                                                         [65]
      VERIFY( )   Verifies whether a character string is, or is not,
                  part of a character set

   --------------------------------------------------------------------
                                   DATE
   --------------------------------------------------------------------


   Purpose

      Returns the local date in the format 'dd mmm yyyy' (for example,
      '22 Apr 1989'), with no leading zero or blank on the day.

   Syntax

      >>-DATE(-+--------+-)--------------------------------------><
               +-option-+

   Parameter

      option The format to use to return the date.  The options are:

             B  (Basedate) Returns the number of complete days (not
                including the current day) since and including the base
                date, January 1, 0001, in the format:  dddddd (no
                leading zeros).  The expression "DATE(B)//7" returns a
                number in the range 0-6, where 0 is Monday and 6 is
                Sunday.

                You can use this option to determine the day of the
                week independent of the national language in which you
                are working.

                Note: The origin of January 1, 0001 is based on the
                Gregorian calendar.  Though this calendar did not exist
                prior to 1582, Basedate is calculated as if it did:
                365 days per year, an extra day every four years except
                century years, and leap centuries if the century is
                divisible by 400.  It does not take into account any
                errors in the calendar system that created the Grego-
                rian calendar originally.

             C  (Century) Returns the number of days, including the
                current day, so far in this century in the format
                'ddddd' (no leading zeros or blanks).

             D  (Days) Returns the number of days, including the
                current day, so far in this year in the format 'ddd'
                (no leading zeros or blanks).

             E  (European) Returns the date in the format 'dd/mm/yy'.

             J  (Julian) Returns the date in the format 'yyddd', where
                'ddd' is the number of days so far in the year.

             L  (Language) Returns the date in the format
                'dd month yyy'.


                                                                                         [66]


             M  (Month) Returns the full name of the current month, in
                mixed case.

             N  (Normal) Explicitly returns the date in the default
                format 'dd mmm yyyy', as described above.

             O  (Ordered) Returns the date in the format 'yy/mm/dd'
                (suitable for sorting).

             S  (Standard) Returns date in the format 'yyyymmdd' (suit-
                able for sorting).  This is one of the three forms
                recommended in the International Standards Organization
                Recommendation ISO/R 2014-1971 (E).  The other two
                forms that document recommends can be derived from this
                form by separating the month from the year and day
                using either blanks or hyphens, for example:'1989 08
                27' or '1989-08-27'.

             U  (USA) Returns the date in the format 'mm/dd/yy'.

             W  (Weekday) Returns the day of the week, in mixed case.

   Examples

      DATE( )             @  '23 Mar 1989'
      DATE('B')           @  726183
      DATE('C')           @  32589
      DATE('D')           @  82
      DATE('E')           @  '23/03/89'
      DATE('J')           @  '89082'
      DATE('L')           @  '23 March 1989'
      DATE('M')           @  'March'
      DATE('N')           @  '23 Mar 1989'
      DATE('O')           @  '89/03/23'
      DATE('S')           @  '19890323'
      DATE('U')           @  '03/23/89'
      DATE('w')           @  'Thursday'

      Note:  The first call to DATE in a clause makes a time stamp,
      which REXX then uses for all calls to DATE or TIME within that
      clause.  This guarantees consistency among multiple calls made to
      DATE or TIME in a single expression or clause.

   See Also

      TIME( )     Returns the local time in many different formats



   --------------------------------------------------------------------
                                  DELSTR
   --------------------------------------------------------------------


   Purpose

      Deletes a substring from a string, by character.
                                                                                         [67]

   Syntax

      >>-DELSTR(string,n-+---------+-)---------------------------><
                         +-,length-+

   Parameters

      string The string from which to delete the substring

      n      The number of the character that determines the start of
             the substring.  N  must be a positive number.  If n is
             greater than the length of string, DELSTR returns the
             string unchanged.

      length The length of the substring.  If you do not specify
             length, DELSTR deletes the rest of the string (including
             the nth character).  Length must be a non-negative whole
             number.

   Examples

      DELSTR('jean',3)     @  'je'
      DELSTR('jeanl',3,2)  @  'jel'
      DELSTR('jeanl',6)    @  'jeanl'

   See Also

      INSERT( )   Inserts a string into another string

      SUBSTR( )   Returns a substring of a string, by character


   --------------------------------------------------------------------
                                  FORMAT
   --------------------------------------------------------------------


   Purpose

      Rounds and formats a number.  For example, you could use this
      function to align the decimal places in figures so that the
      figures align into columns, or to round numbers at a specific
      point in your calculations.

   Syntax

      >>-FORMAT(number+-----------------------------------+-)----><
                      +,+------++------------------------++
                        +before++,+-----+----------------+
                                  +after+             

   Parameters

      number The number to format.  The number is rounded and formatted
             according to standard REXX rules, just as though the oper-
             ation "number+0" had been carried out.

      before The number of character positions before the decimal
                                                                                         [68]
             point.  If before is not large enough to contain the
             integer part of the number, an error results.

      after  The number of character positions after the decimal point.
             If after is not the same size as the decimal part of the
             number, FORMAT rounds the number to fit, or extends the
             number with zeros.  If you specify 0, FORMAT rounds the
             number to an integer (that is, it will have no decimal
             part).

             Note:  If you do not specify either before or after,
             FORMAT uses as many characters as it needs for that part.


   Examples

      FORMAT('3',4)             @  '   3'
      FORMAT('1.93',4,0)        @  '   2'
      FORMAT('1.93',4,3)        @  '   1.930'
      FORMAT('-.76',4,1)        @  '  -0.8'
      FORMAT('3.03',4)          @  '   3.03'
      FORMAT(' -12.93',,4)     @  '-12.9300'
      FORMAT(' -12.93')        @  '-12.93'
      FORMAT('0.000')           @  '0'



   --------------------------------------------------------------------
                                  INSERT
   --------------------------------------------------------------------


   Purpose

      Inserts a string into another string.

   Syntax

      >>-INSERT(string,target-+----------------------------+-)---><
                              +,+---++--------------------++
                                +-n-++,+--------+-+------++
                                       +-length-+ +-,pad-+

   Parameters

      string The string to be inserted

      target The string in which to insert the other string

      n      The character position after which to insert string.  The
             default is 0, which inserts the string before the begin-
             ning of the target string.  n  must be a non-negative
             whole number.  If n is greater than the length of the
             target string, INSERT adds padding before the string.

      length The length of the string to be inserted.  String is padded
             on the right or truncated to the right according to this
             length.  The length must be a non-negative whole number.
             The default is the length of the insert string (string).
                                                                                         [69]

      pad    The character to use for padding.  The default character
             is a blank.

   Examples

      INSERT(' ' , 'abcdef' ,3)    @  'abc def'
      INSERT('123', 'abc' ,5,6)    @  'abc  123   '
      INSERT('123','abc',5,6,'+')  @  'abc++123+++'
      INSERT('123','abc')          @  '123abc'
      INSERT('123','abc',,5,'-')   @  '123--abc'
      INSERT('123','abc',5,,'-')   @  'abc--123'          

   See Also

      COPIES( )   Returns a number of copies of a string, directly
                  concatenated

      SUBSTR( )   Returns a substring of a string, by character



   --------------------------------------------------------------------
                                 LASTPOS
   --------------------------------------------------------------------


   Purpose

      Finds the position of a substring in another string, by scanning
      backwards.

   Syntax

      >>-LASTPOS(needle,haystack-+--------+-)--------------------><
                                 +-,start-+

   Parameters

      needle   The string to find

      haystack The string to search

      start    The point at which to start the backwards scan.  Start
               must be a positive whole number.  The default is to
               start at the last character of haystack and scan back-
               wards.

   Remarks

      Returns the position of the last occurrence of needle, in
      haystack.  If it does not find needle, LASTPOS returns 0.

   Examples

      LASTPOS(' ','abc def ghi')    @  8
      LASTPOS(' ','abcdefghi')      @  0
      LASTPOS(' ','abc def ghi',7)  @  4

                                                                                         [70]
   See Also

      POS( )      Returns the position of a substring in another string

      WORDPOS( )  Searches a string for a phrase, and returns the
                  number of the first word in the phrase


   --------------------------------------------------------------------
                                   LEFT
   --------------------------------------------------------------------


   Purpose

      Returns the leftmost characters of a string.

   Syntax

      >>-LEFT(string,length-+------+-)---------------------------><
                            +-,pad-+

   Parameters

      string The string to be truncated or padded.

      length The length of the returned string. Length must be a
             non-negative whole number.

      pad    The character to use to pad the string if it is shorter
             than the length.  The default character is a blank.

   Remarks

      If string is longer than length, LEFT truncates the extra charac-
      ters.  If string is shorter than length, LEFT pads on the right.

      This function is exactly the same as:

      >>-SUBSTR(string,1,length-+------+-)-----------><
                                +-,pad-+

   Examples

      LEFT('abc d',8)     @  'abc d   '
      LEFT('abc d',8,'.') @  'abc d...'
      LEFT('abc def',6)   @   'abc de'

   See Also

      RIGHT( )    Returns characters from the right side of a string



                                                                                         [71]
   --------------------------------------------------------------------
                                  LENGTH
   --------------------------------------------------------------------


   Purpose

      Returns the length of a string.

   Syntax

      >>-LENGTH(string)------------------------------------------><

   Parameter

      string The string to evaluate

   Examples

      LENGTH('abc')         @  3
      LENGTH('abcdefghij')  @  10
      LENGTH('')            @  0

   See Also

      WORDS( )    Returns the number of blank-delimited words in a
                  string



   --------------------------------------------------------------------
                                  LINEIN
   --------------------------------------------------------------------


   Purpose

      Returns lines read from a character input stream.

   Syntax

      >>-LINEIN(--name----+----------------------+-)-------------><
                          +-,-+------++--------+-+
                              +-line-++-,count-+

   Parameters

      name   The file name, which can be any system file.  The file
             name can include drive and path specifications.  

      line   The line number, which sets the read position to the start
             of a specific line.  A value of 1 specifies the first line
             in the stream.  The default is the current read position.
             When LINEIN completes the read, it increases the read
             position by the number of characters read.

             For persistent streams (for example, files) REXX maintains
             a read position for each stream.  You cannot specify a
             read position for a transient stream.

             Under certain circumstances, a call to LINEIN returns a
             partial line.  For example, when the stream has already
             been read with the CHARIN function, and part but not all
             of a line (and its termination) has been read.
                                                                                         [72]

      count  The number of lines read.  The default is 1.  If you
             specify a count of 0, REXX sets the read position to the
             start of line, but does not read any characters and
             returns the null string.

   Remarks

      LINEIN may return a partial line if part of a line has been read
      using the CHARIN function, and line termination was not read.



   Examples

      1 LINEIN(infile)      @  'ABC'
      2 LINEIN(infile,3)    @  'Line3'
      3 LINEIN(infile,8,0)  @  ''
      4 LINEIN(infile)      @  'Line8'

        1:Reads the current line
        2:Reads line 3
        3:Sets the read position at line 8
        4:Reads line 8

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream



   --------------------------------------------------------------------
                                 LINEOUT
   --------------------------------------------------------------------


   Purpose

      Writes a string to a character output stream.

   Syntax

      >>-LINEOUT(---name---+-----------------------+-)-----------><
                           +-,-+--------++-------+-+
                               +-string-++-,line-+
                                                                                         [73]

   Parameters

      name   The name of the output device, which is usually a file
             name.  The file name can include drive and path specifica-
             tions. 

      string The string to write.  You can specify the null string, in
             which case only the action associated with completing the
             line is taken.  You can omit this argument for persistent
             streams, for example, files and objects.  In this case,
             CHAROUT sets the write position to the value of line, does
             not write any lines to the stream, and returns 0.

      line   The explicit write position for the write to start.  The
             line number must be positive and within the bounds of the
             stream, although it can specify the character position
             immediately after the end of the stream.  A value of 1
             specifies to start the write at the first line in the
             stream.  The default is to start at the current write
             position.

   Remarks

      For persistent streams, LINEOUT maintains a write position for
      each stream.  LINEOUT conceptually terminates a line at the end
      of each call.  When LINEOUT completes the write, it increases the
      write position by the number of characters written.  The initial
      write position is the end of the stream, so that calls to LINEOUT
      normally append lines to the end of the stream.  (Unless the
      stream was opened using the STREAM() function).

      If you do not specify a line position or a string, LINEOUT sets
      the write position to the end of the stream, closes the file, and
      returns 0.

      The program stops executing until the output operation is effec-
      tively complete.  If, however, LINEOUT cannot write all the char-
      acters, it returns with the number of lines that could not be
      written (the residual count).



   Examples

      1 LINEOUT(outfile,'At')    @  0
      2 LINEOUT(outfile,'At',4)  @  0
      3 LINEOUT(outfile,,5)      @  0
      4 LINEOUT(outfile)         @  0

        1:Indicates a normal return
        2:Indicates a normal return
        3:Sets the write position to line 5
        4:Sets the write position to the end of file

   Examples

      This routine is often best called as a subroutine.  The residual
      count is then available in the special variable RESULT.
                                                                                         [74]

      Call LINEOUT(outfile, 'Think')
      Call LINEOUT(outfile, 'At',5)
      Call LINEOUT(outfile)

      Note:  If the lines are to be written to the default output
      stream and no error is possible, you would usually use the SAY
      instruction.

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream



   --------------------------------------------------------------------
                                  LINES
   --------------------------------------------------------------------


   Purpose

      Returns the total number of complete lines remaining in a
      character input stream.  For persistent streams, the count starts
      at the current read position.

   Syntax

      >>-LINES(--name--)----------------------------------------><

   Parameter

      name   The file name, which can be any system file name,
             including specific device names.  If you omit name, LINES
             returns the number of lines available in the default input
             stream.

   Remarks

      1. If a stream has been read with the CHARIN function, the number
         of complete lines might include a partial line.

      2. If LINES cannot determine the count accurately or efficiently,
                                                                                         [75]
         it might return 1 or more for any nonzero result.

      3. Use the CHARS function to return the number of characters
         (rather than lines) in the stream.

   Examples

      LINES(myfile)       @  42
      LINES(nonfile)      @  0
      LINES( )            @  27

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      LINEOUT( )  Writes a string to a character output stream

      STREAM( )   Performs an operation on a stream or requests infor-
                  mation about a stream


   --------------------------------------------------------------------
                                 OVERLAY
   --------------------------------------------------------------------


   Purpose

      Overlays one string onto another string.

   Syntax

      >>-OVERLAY(string,target-+----------------------------+)---><
                               +,+---++--------------------++
                                 +-n-++,+--------+-+------++
                                        +-length-+ +-,pad-+

   Parameters

      string The overlay string

      target The string that will be overlaid

      n      The position in the target string where overlaying is to
             start.  N must be greater than 0.  If n is greater than
             the length of the target string, OVERLAY adds padding
             before the overlay string.

      length The length of the overlay string.  String is padded on the
             right or truncated on the right according to length.
             Length must be a non-negative whole number.  The default
                                                                                         [76]
             is the length of the overlay string.

      pad    The character to use for padding.  The default character
             is a blank.

   Remarks

      The function overlays target, starting at the nth character, with
      string.  Before target is overlaid, string will be padded or
      truncated to the size given by length.

   Examples

      OVERLAY(' ','abcdef',4)       @  'abc ef'
      OVERLAY('.','abcdef',4,2)     @  'abc. f'
      OVERLAY('zz','abcd')          @  'zzcd'
      OVERLAY('zz','abcd',4)        @  'abczz'
      OVERLAY('zz','abcd',6,7,'-')  @  'abcd-zz-----'



   See Also

      INSERT( )   Inserts a string into another string


   --------------------------------------------------------------------
                                   POS
   --------------------------------------------------------------------


   Purpose

      Returns the position of a substring in another string.

   Syntax

      >>-POS(needle,haystack-+--------+-)------------------------><
                             +-,start-+

   Parameters

      needle   The substring to find

      haystack The string to search

      start    The point at which to start the search.  The default is
               the first character of haystack (that is, start has the
               value 1). Start must be a positive whole number.

   Remarks

      Returns the position of the first occurence of needle in
      haystack.  If POS does not find the string needle, it returns 0.

   Examples

      POS('is','now is the')    @  5
      POS('at','now is the')    @  0
                                                                                         [77]
      POS(' ','abc def ghi')    @  4
      POS(' ','abc def ghi',5)  @  8

   See Also

      LASTPOS( )  Finds the position of a substring in another string,
                  by scanning backwards

      WORDPOS( )  Searches a string for a phrase, and returns the
                  number of the first word in the phrase




   --------------------------------------------------------------------
                                  QUEUED
   --------------------------------------------------------------------


   Purpose

      Returns the number of lines remaining in the external data queue
      when the function is invoked.  See "Input and Output" on page
      108.

   Syntax

      >>-QUEUED()------------------------------------------------><

   Example

      QUEUED( )           @  5

   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      LINES( )    Returns the total number of lines remaining in a
                  character input stream



   --------------------------------------------------------------------
                                  RANDOM
   --------------------------------------------------------------------


   Purpose

      Returns a non-negative whole number chosen at random from an
      inclusive range of numbers.  This can be useful for programming
      games and for statistical models.

   Syntax

      >>-RANDOM(-+--------------------------+-)------------------><
                 +-max----------------------+
                 +-min,-+--+-----++-------+-+
                                                                                         [78]
                 +-,----+  +-max-++-,seed-+

   Parameters

      min    The minimum number in the range.  The default is 0.

      max    The maximum number in the range.  The default is 999.

      seed   The random number that starts a repeatable sequence of
             results.  Seed must be a whole number.

   Remarks

      The magnitude of the range (that is, max minus min) cannot exceed
      100000.

   Examples

      /* Possible results might be: */
      RANDOM( )           @  305
      RANDOM(5,8)         @  7
      RANDOM(,,1989)      @  558 /* always */
      RANDOM(2)           @  0

   Remarks

      1. To obtain a predictable sequence of quasi-random numbers, call
         RANDOM a number of times, but only specify a seed on the first
         call.  For example, to simulate ten throws of a six-sided
         dice:

         /* Start invoking any number for the seed */
            say random(1,6,777)
             do 9
            say random(1,6)
             end

         The numbers are generated mathematically, using the initial
         seed, They appear to be random as far as possible.  Running



         the program again will produce the same sequence.  However,
         using a different initial seed almost always produces a
         different sequence.  If you do not supply a seed the first
         time RANDOM is called, REXX uses an arbitrary (and probably
         time-varying) initial seed.


   --------------------------------------------------------------------
                                 REGEXP
   --------------------------------------------------------------------


   Purpose

      Evaluate a regular expression.

   Syntax
                                                                                         [79]

      >>-REGEXP(Stem, Value, Expression) ------------------------------><

   Parameter

      Stem         The variable-array that receives the parsed values
      Value        The string to be evaluated
      Expression   The regular expression to be used for the evaluation 
      function     1 (True), if at least one resulting value was parsed

   Example

      regexp("a.", "aa ss vv", "\w*" @ 1
                                       a.0 = 3
                                       a.1 = aa
                                       a.2 = ss
                                       a.3 = vv                                                        

   --------------------------------------------------------------------
                                 REVERSE
   --------------------------------------------------------------------


   Purpose

      Reverses the order of characters in a string.

   Syntax
                                                                                         [79]

      >>-REVERSE(string)-----------------------------------------><

   Parameter

      string The string to reverse

   Examples

      REVERSE('Bel.')            @  '.leB'
      REVERSE('TIN ')            @  'NIT'
      REVERSE('AlphabetStreet')  @  'teertStebahplA'
                                                          

   --------------------------------------------------------------------
                                  RIGHT
   --------------------------------------------------------------------


   Purpose

      Returns the rightmost characters of a string.

   Syntax

      >>-RIGHT(string,length-+------+-)--------------------------><
                             +-,pad-+

   Parameters

      string The string to be truncated or padded.

      length The length of the result string. length must be a
             non-negative whole number.

      pad    The character to use to pad the string if it is shorter
             than the length.  The default character is a blank.

   Remarks

      If string is longer than length, RIGHT truncates the extra char-
      acters on the left.  If string is shorter than length, RIGHT pads
      on the left.

   Examples

      1 RIGHT('abcd',6)     @  '  abcd'
      2 RIGHT('abcdef',4)   @  'cdef'
      3 RIGHT('123',6,'0')  @  '000123'

        1:Pads the result on the left
        2:Truncates the result on the left
        3:Pads the result with '0'

   See Also

      LEFT( )     Returns characters from the left side of a string

      SPACE( )    Formats the words in a string with pad characters
                                                                                         [80]
                  between each word


   --------------------------------------------------------------------
                                   SIGN
   --------------------------------------------------------------------


   Purpose

      Tests a number for greater than, less than, or equal to zero
      after rounding.

   Syntax

      >>-SIGN(number)--------------------------------------------><

   Parameter

      number The number to evaluate.

   Remarks

      If the number is then less than 0,
      SIGN returns '-1'.  If it is 0, SIGN returns '0'.  If it is
      greater than 0, SIGN returns '1'.

   Examples

      SIGN('123')         @  1
      SIGN('123.45')      @  1
      SIGN('-123')        @  -1
      SIGN(0.0)           @  0

   See Also

      ABS( )      Returns the absolute value of a number


   --------------------------------------------------------------------
                                  STREAM
   --------------------------------------------------------------------


   Purpose

      Opens a file for subsequent use by LINE... or CHAR... functions.
      Closes an open file.
      Returns a string that describes the state of, or results of an
      operation upon, a character stream.  See "Input and Output" on
      page 108.  You can use this function to retrieve information
      about the state of a particular input or output stream, or to
      perform an operation on the stream.

   Syntax

      >>-STREAM(name-,-+-S---------------------+-)---------------><
                       |                       |
                       +-D---------------------+
                                                                                         [81]
                       |                       |
                       +-C-+-OPEN-access-mode-++
                           |                  |
                           +-CLOSE------------+
                           |                  |
                           +-RESET------------+
                           |                  |
                           +-SEEK-offset------+
                           |                  |
                           +-QUERY-type-------+

   Parameters

      name       The stream to access.  If you do not specify a stream
                 name, REXX carries out the operation on the default
                 input stream.

      operation  The operation to perform.  The operations are:

                 S  (State)  Returns a string that describes the
                    current state of the stream; for example, the
                    stream is READY or NOTREADY.  This is the default.

                 D  (Description)  Returns a more detailed description
                    of the current state of the stream.  The returned
                    string is followed by a colon, and if available, an
                    additional descriptive string.

                 C  (Command)  Specifies a "command" or operation to
                    perform on the selected input or output stream.
                    The returned string depends on the command, and
                    might be the null string.  See "Stream commands" on
                    page 80 for a list of valid commands.

   Remarks

      When you specify the State or Description options, STREAM returns
      one of the following strings:



      ERROR    An operation on a stream resulted in an error.  To find
               out more about the error, use the Description operation
               described above.

      NOTREADY The stream is not ready for normal input or output oper-
               ations.

      READY    The stream is ready for normal input or output opera-
               tions.

      UNKNOWN  The current state of the stream is unknown.  REXX cannot
               determine the state of the stream until it performs an
               operation on it.


   Stream commands

      Stream commands let you:

      *  Open and close a stream
                                                                                         [82]

      *  Get information about a stream

      *  Set or get the file pointer position in a stream

      To issue a stream command, use the Command option, and enclose
      the stream command in quotes.  For example:

      stream(name,c,'open write')

      The stream commands are:

      OPEN       Opens the stream according to "access". Access may be  
                 either READ or WRITE or blank. Mode may be TEXT or
                 BINARY. The default is to open for both reading and 
                 writing data in text mode, for example, 
                 STREAM( filename, 'C', 'OPEN TEXT' ).   
                 To open the stream for reading only, specify READ.  To
                 open the stream for writing only, specify WRITE.  To
                 open the stream in binary mode, specify BINARY.

                 If the stream is opened successfully, STREAM returns
                 READY.  If the stream open failed, STREAM returns an
                 appropriate error message.

      CLOSE      Closes the stream.  If the stream is closed success-
                 fully, STREAM returns READY.  If the stream close
                 failed, STREAM returns an appropriate error message.
                 If you try to close an unopened stream, STREAM returns
                 a null string.

      RESET      Optionally closes a stream and deletes the underlying file.

      SEEK offsetSets an explicit read or write position within a
                 persistent stream.  See "Input and Output" on page
                 108.  Before you use this command, you must issue the
                 OPEN stream command.  Then, issue the SEEK command
                 with the number of characters from the beginning of a
                 persistent stream.  You can also precede the offset
                 number with one of the following characters:


                 =  Explicitly specifies the offset from the beginning
                    of the stream.

                 <  Specifies the offset from the end of the stream.

                 +  Specifies the offset forward from the current read
                    or write position.

                 -  Specifies the offset backward from the current read
                    or write position.

      QUERY type Returns specific information about a streem depending
                 the type:

                 EXIST    Returns the full path specification of the
                          stream, if it exists.  Returns a null string
                          if it does not exist.

                 SIZE     Returns the size of a persistent stream (in
                                                                                         [83]
                          bytes).

                 DATETIME Returns the date and time stamps of a stream.

   Remarks

      The STREAM seek function returns the file pointer position after
      the seek operation.

   Examples

      1 stream(name,c,'OPEN')
      2 stream(name,c,'OPEN TEXT')
      3 stream(name,c,'OPEN READ')
      4 stream(name,c,'OPEN READ TEXT')
      5 stream(name,c,'OPEN WRITE')
      6 stream(name,c,'OPEN WRITE TEXT')
      7 stream(name,c,'OPEN BINARY')
      8 stream(name,c,'OPEN READ BINARY')
      9 stream(name,c,'OPEN WRITE BINARY')
      10stream(name,'C','SEEK +0')
      11stream(name,'C','SEEK +2')

        1:opens the stream for reading and writing in text mode
        2:opens the stream for reading and writing in text mode
        3:opens the stream for reading in text mode
        4:opens the stream for reading in text mode
        5:opens the stream for writing in text mode
        6:opens the stream for writing in text mode
        7:opens the stream for reading and writing in binary mode
        8:opens the stream for reading in binary mode
        9:opens the stream for writing in binary mode
        10:returns 20
        11:returns 22



   See Also

      CHARS( )    Returns the total number of characters remaining in a
                  character input stream

      CHARIN( )   Returns a string of characters read from a character
                  input stream

      CHAROUT( )  Writes  a string to a character output stream

      LINES( )    Returns the total number of complete lines remaining
                  in a character input stream

      LINEOUT( )  Writes a string to a character output stream

      LINEIN( )   Returns a line from a character input stream

      QUEUED( )   Returns the number of lines remaining in the external
                  data queue


                                                                                         [84]
   --------------------------------------------------------------------
                                  STRIP
   --------------------------------------------------------------------


   Purpose

      Removes the leading, trailing, or both leading and trailing char-
      acters from a string.

   Syntax

      >>-STRIP(string-+----------------------+-)-----------------><
                      +-,-+--------++-------++
                          +-option-++-,char-+

   Parameters

      string The string from which to remove the characters

      option The type of characters to remove.  The options can be in
             upper or lowercase.  The options are:

             L  Removes leading characters

             T  Removes trailing characters

             B  Removes both leading and trailing characters (the
                default).

      char   The character to remove.  The default is a blank.  Char
             must be exactly one character long.

   Examples

      STRIP('  ab cd  ')      @  'ab cd'
      STRIP('  ab cd  ','B')  @  'ab cd'
      STRIP('  ab cd  ','L')  @  'ab cd  '
      STRIP('  ab cd  ','T')  @  '  ab cd'
      STRIP('12.3400',,0)     @  '12.34'
      STRIP('0012.3400',,0)   @  '12.34'        

   See Also

      LEFT( )     Returns characters from the left side of a string

      RIGHT( )    Returns characters from the right side of a string


   --------------------------------------------------------------------
                                  SUBSTR
   --------------------------------------------------------------------


   Purpose

      Returns a substring of a string, by character.

   Syntax

                                                                                         [85]
      >>-SUBSTR(string,n-+---------------------+-)---------------><
                         +-,-+--------++------++
                             +-length-++-,pad-+

   Parameters

      string The string from which to derive the substring.

      n      The character position at which to start the substring.  N
             must be positive.  If n is greater than the length of the
             string, SUBSTR returns pad characters only.

      length The length of the substring.  The default is the rest of
             the string.

      pad    The pad character to use to pad the substring, if neces-
             sary.  The default character is a blank.

      Note:   In some situations it might be more convenient to use the
      positional (numeric) patterns of parsing templates to select
      substrings, especially if you want to extract more than one
      substring from a string.

   Examples

      SUBSTR('abcde',2)        @  'bcde'
      SUBSTR('abcde',2,5)      @  'bcde '
      SUBSTR('abcde',1,3)      @  'abc'
      SUBSTR('abcde',2,6,'.')  @  'bcde..'

   See Also

      LEFT( )     Returns characters from the left side of a string

      RIGHT( )    Returns characters from the right side of a string

      STRIP( )    Removes the leading, trailing, or both leading and
                  trailing characters from a string.



   --------------------------------------------------------------------
                                   TIME
   --------------------------------------------------------------------


   Purpose

      Returns the local time.  The default format is the 24-hour clock,
      'hh:mm:ss' (hours, minutes, and seconds).  For example,
      '04:41:37'.

   Syntax

      >>-TIME(option)--------------------------------------------><

   Parameter

      option Returns a different format or accesses the elapsed time
                                                                                         [86]
             clock.  The options are:

             C  (Civil) Returns 'hh:mmxx', the time in civil format, in
                which the hours can take the values 1 through 12, and
                the minutes the values 00 through 59.  The minutes are
                followed immediately by the letters "am" or "pm".  The
                hour does not have a leading zero.  The minute field
                shows the current minute (rather than the nearest
                minute) for consistency with other TIME results.

             E  (Elapsed) Returns 'sssssssss.uuuuuu', the number of
                seconds (and microseconds) since the elapsed time clock
                was started or reset (see below).  The number does not
                have leading zeros or blanks, and is not affected by
                the setting of NUMERIC DIGITS.

             H  (Hours) Returns the number of hours since midnight in
                the format 'hh' (no leading zeros or blanks).

             L  (Long) Returns the time in the format 'hh:mm:ss.uuuuuu'
                (uuuuuu is the fraction of seconds, in microseconds).

             M  (Minutes) Returns the number of minutes since midnight
                in the format 'mmmm' (no leading zeros or blanks).

             N  (Normal) Explicitly returns the time in the default
                format 'hh:mm:ss', as described above.

             R  (Reset) Returns  'sssssssss.uuuuuu', the number of
                seconds.microseconds since the elapsed time clock was
                started or reset (see below), and also simultaneously
                resets the elapsed time clock to zero.  The number does
                not have leading zeros or blanks, and is not affected
                by the setting of NUMERIC DIGITS.

             S  (Seconds) Returns number of seconds since midnight in
                the format 'sssss' (no leading zeros or blanks).



   Examples

      1 TIME('C')  @  '4:54pm'
      2 TIME('H')  @  16
      3 TIME('L')  @  '16:54:22.123456'
      4 TIME('M')  @  1014
      5 TIME('n')  @  '16:54:22'
      6 TIME('s')  @  60862
                                           
        4: 54 + 60*16
        6: 22 + 60*(54 + 60*16)

   Example

      Measuring elapsed time intervals

      You can use the TIME function to measure real (elapsed) time
      intervals.  On the first call in a program to TIME('E') or
      TIME('R'), the elapsed time clock is started and either call
                                                                                         [87]
      returns 0.  From then on, calls to TIME('E') and to TIME('R')
      return the elapsed time since that first call or since the last
      call to TIME('R').

      1 TIME('E')  @  0
      2 TIME('E')  @  1.002345
      3 TIME('R')  @  2.004690
      4 TIME('R')  @  1.002345

        1:The first call pause of one second
        2:One second pause, or thereabouts
        3:One second pause, or thereabouts
        4:Or thereabouts

      Note:  The first call to TIME in a clause makes a time stamp,
      which REXX then uses for all calls to TIME or DATE within that
      clause.  This guarantees consistency among multiple calls made to
      TIME or DATE in a single expression or clause.  Since the clock
      is synchronized, the interval between two normal TIME results can
      be calculated exactly by the elapsed time clock.

   See Also

      DATE( )     Returns the local date in many different formats


   --------------------------------------------------------------------
                                  TRACE
   --------------------------------------------------------------------


   Purpose

      Returns the trace setting currently in effect, and optionally
      alters the setting.

   Syntax

      >>-TRACE(-+---------+-)------------------------------------><
                +-setting-+

   Parameter

      setting  Selects the trace setting.  setting must be a valid
               prefix ("?") and/or one of the following:

               I  (Intermediates) as "R" except that all terms and
                  intermediate results during expression evaluation
                  (and substituted names) are also traced.

               L  (Labels) Traces only labels passed during execution.
                  This is especially useful while tracing
                  interactively, when the language processor pauses
                  after each label; or if you want to note all internal
                  subroutine calls and signals.

               N  (Normal) Traces nothing except host commands
                  resulting in failure.  These are traced (after execu-
                  tion) together with the return code from the command.
                                                                                         [88]
                  This is the default.


               R  (Results) Traces all clauses before execution,
                  together with the final result of any expression
                  evaluated.  Values assigned during PULL, ARG, and
                  PARSE instructions are also displayed.  We recommend
                  this setting for general debugging.


   --------------------------------------------------------------------
                                TRANSLATE
   --------------------------------------------------------------------


   Purpose

      Translates characters in a string to other characters, or reor-
      ders characters in a string.  For example, you might use this
      function to translate data before sending it from an EBCDIC
      computer to an ASCII printer or to change the punctuation in a
      program.

   Syntax

      >>-TRANSLATE(string+-------------------------------+-)-----><
                         +-,-+------++------------------++
                             +tableo++-,-+------+-+----++
                                         +tablei+ +,pad+

   Parameters

      string The string to translate or reorder

      tableo The output translate table to use for the translation.
             The default output table is the null string.  Tableo is
             padded or truncated on the right as needed.

      tablei The input translate table to use for the translation.  The
             default is XRANGE('00'x,'FF'x).

      pad    The pad character to use to pad the default output table.
             The default pad character is a blank.

   Remarks

      If you do not specify either table, TRANSLATE simply translates
      the string to upper case.

      The tables can be any length: TRANSLATE uses the first occurrence
      of a character in the input table if there are duplicates.  If
      the length of the output table is less than the length of the
      input table, the output table is padded on the right with the pad
      character.  All characters in string that are found in tablei
      will be replaced by corresponding characters in tableo.  If a
      character in string does not appear in tablei, it appears in the
      result string unchanged.


                                                                                         [89]

   Examples

      TRANSLATE('abcdef')                  @  'ABCDEF'
      TRANSLATE('abbc','-','b')            @  'a--c'
      TRANSLATE('abcdef','12','db')        @  'a2c1ef'
      TRANSLATE('abcdef','12','abcd','.')  @  '12..ef'
      TRANSLATE('file.ext',' ','.')        @  'file ext'
      TRANSLATE('4123','abcd','1234')      @  'dabc'

      Note: The last example shows how the TRANSLATE function can be
      used to reorder the characters in a string.  In the example, any
      4-character string could be specified as the second argument, and
      its last character would be moved to the beginning of the string.

   See Also

      REVERSE( )  Swaps a string end for end

      VERIFY( )   Verifies whether a character string is, or is not, a
                  member of a given character set


   --------------------------------------------------------------------
                                  TRUNC
   --------------------------------------------------------------------


   Purpose

      Rounds a number down.

   Syntax

      >>-TRUNC(number-+----+-)-----------------------------------><
                      +-,n-+

   Parameters

      number The number to round down

      n      The number of digits after the decimal point.  n must be a
             non-negative whole number.  The default is 0, which
             returns an integer with no decimal point.  TRUNC truncates
             the number to n decimal places, or adds trailing zeros if
             needed to make up the specified length.  The result is
             never in exponential form.

   Examples

      TRUNC(123.45)       @  123
      TRUNC(123.4567,3)   @  123.456
      TRUNC(123.4,3)      @  123.400
      TRUNC(123,2)        @  123.00

      Note: The number will be rounded according to the current setting
      of NUMERIC DIGITS, if necessary, before being processed by the
      function.

                                                                                         [90]
   See Also

      FORMAT( )   Rounds and formats a number


   --------------------------------------------------------------------
                                  VALUE
   --------------------------------------------------------------------


   Purpose

      Returns the value of a symbol, and optionally assigns it a new
      value.

   Syntax

      >>-VALUE(name-+-------------------------------+-)----------><
                    +-,-+----------++--------------++
                        +-newvalue-++-,environment-+

   Parameters

      name        The symbol name to evaluate, which must be a valid
                  REXX symbol.  VALUE translates lowercase characters
                  in the name to upper case and performs substitution
                  in a compound name.

      newvalue    The new value to assign to the symbol.   The new
                  value does not affect the result returned.

      environment The variables environment to manipulate.  By default,
                  VALUE refers to the current REXX variables environ-
                  ment.    You can use this option to select an
                  external collection of variables.  For example, to
                  manipulate system environment variables, environment
                  must be CMD, or an expression so evaluated.  If you
                  select a variables environment other than the REXX
                  variables environment, name does not have to be a
                  valid REXX symbol.

   Examples

      These examples follow:  Drop A1; A11=7; K=1; rick='K'

      1 VALUE('rick')                 @  'K'
      2 VALUE(rick)                   @  '1'
      3 VALUE('a'k)                   @  'A1'
      4 VALUE('a'k||k)                @  '7'
      5 VALUE('a1','Steak')           @  'A1'
      6 VALUE('a1')                   @  'Steak'
      7 VALUE('path',,'CMD')          @  'C:\OS2'
      8 VALUE('EVAR','FooBar','CMD')  @  ''
      9 VALUE('EVAR','','CMD')        @  'FooBar'

        1:'rick' is looked up; 'K' returned
        2:RICK has the value 'K'; 'K' is looked up; '1' returned
        3:A1 has the value 'A1'; 'A1' is looked up; 'A1' returned
        4:A11 is looked up; '7' returned
                                                                                         [91]
        5:Assign REXX variable A1 the value 'Steak'
        6:Get value of A1; it is now 'Steak'


        7:Get the system PATH environment variable
        8:Set a system environment variable named EVAR with the value
          'FooBar'
        9:Get the value of system environment variable 'EVAR'

   Remarks

      1. Use the SYMBOL function to test the validity of a symbol.

      2. Use the VALUE function when a variable contains the name of
         another variable, or when a name is constructed dynamically,
         as in examples 3 and 4.  It is not useful to specify the name
         as a quoted literal string, since the symbol is then constant,
         and so the whole function call could be replaced directly by
         the string between the quotes.  (For example,
         "rick=Value('k');" is always identical to the assignment
         "rick=k;".)

   See Also

      SYMBOL( )   Indicates whether a symbol has already been used as a
                  name of a variable


   --------------------------------------------------------------------
                                  VERIFY
   --------------------------------------------------------------------


   Purpose

      Verifies whether a character is, or is not, a member of a given
      character set.

   Syntax

      >>-VERIFY(string,reference-+-----------------------+-)-----><
                                 +-,-+--------++--------++
                                     +-option-++-,start-+

   Parameters

      string     The string to verify

      reference  The character set to use to check the string

      option     The verification method.  The options are:

                 N  No match, which returns the position of the first
                    character in string that is not in reference.  If
                    all characters in string are also found in
                    reference, zero is returned.  This is the default
                    option.

                 M  Match, which returns the position of the first
                                                                                         [92]
                    character in string that is also in reference, or 0
                    if it finds none of the characters.

      start      The character position to start the search.  The
                 default is 1, which starts the search at the first
                 character of string. Start must be a non-negative
                 whole number.

   Remarks

      If string is null, VERIFY returns 0, regardless of the value of
      option.  Similarly if start is greater than LENGTH(string),
      VERIFY returns 0.

   Examples

      VERIFY('123','1234567890')            @  0
      VERIFY('12Z','1234567890')            @  3
      VERIFY('123','1234567890','M')        @  1
      VERIFY('AB7D','1234567890','M')       @  3
      VERIFY('A12Y4','1234567890',,3)       @  4
      VERIFY('ABC1EF4','1234567890','M',5)  @  7

   See Also

      TRANSLATE( )Translates characters in a string

      DATATYPE( ) Checks that characters in a string are valid
                  according to some data type.



   --------------------------------------------------------------------
                                   WORD
   --------------------------------------------------------------------


   Purpose

      Returns a word from a string.

   Syntax

      >>-WORD(string,n)------------------------------------------><

   Parameters

      string The string in which the word appears

      n      The number of the word in the string

   Remarks

      If there are less than n words in string, WORD returns the null
      string.  This function is exactly equivalent to

      SUBWORD(string,n,1).

   Examples
                                                                                         [93]

      WORD('Now is the time',3)  @  'the'
      WORD('Now is the time',5)  @  ''

   See Also

      WORDS( )    Returns the number of blank-delimited words in a
                  string


   --------------------------------------------------------------------
                                  WORDS
   --------------------------------------------------------------------


   Purpose

      Returns the number of blank-delimited words in a string.

   Syntax

      >>-WORDS(string)-------------------------------------------><

   Parameter

      string The string to evaluate

   Examples

      WORDS('Now is the time')    @  4
      WORDS('Now   is the time')  @  4
      WORDS(' ')                  @  0

   See Also

      WORD( )     Returns a word from a string.


   --------------------------------------------------------------------
                                  XRANGE
   --------------------------------------------------------------------


   Purpose

      Returns a string of all one byte character representations within
      a range of characters.

   Syntax

      >>-XRANGE(-+-------++------+-)-----------------------------><
                 +-start-++-,end-+

   Parameters

      start  The starting character.  The default is '00'x.

      end    The ending character.  The default is 'FF'x.

                                                                                         [94]
   Remarks

      If start is greater than end, the values will wrap from 'FF'x to
      '00'x.  start and end must be single characters.

   Examples

      XRANGE('a','f')     @  'abcdef'
      XRANGE('03'x,'07'x) @  '0304050607'x
      XRANGE(,'04'x)      @  '0001020304'x
      XRANGE('FE'x,'02'x) @  'FEFF000102'x



   --------------------------------------------------------------------
                                   X2B
   --------------------------------------------------------------------


   Purpose

      Converts a value in hexadecimal to a binary string.

   Syntax

      >>-X2B(hex-string)-----------------------------------------><

   Parameter

      hex-string The hexadecimal string to convert, which can be the
                 null string, in which case X2B returns a null string.

   Remarks

      You can optionally add blanks at byte boundaries (not leading or
      trailing) to aid readability; they are ignored.

   Examples

      X2B('CF')           @  '11001111'B
      X2B('1700')         @  '0001011100000000'B
      X2B('41')           @  '01000001'B
      X2B(' ')            @  ''

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      X2C( )      Converts a value in hexadecimal to an ASCII character


                                                                                         [95]
   --------------------------------------------------------------------
                                   X2C
   --------------------------------------------------------------------


   Purpose

      Converts hexadecimal to character (packs).

   Syntax

      >>-X2C(hex-string)-----------------------------------------><

   Parameter

      hex-string The hexadecimal string to pack, which can be the null
                 string, in which case X2C returns a null string.

   Remarks

      You can optionally add blanks at byte boundaries (not leading or
      trailing) to aid readability; they are ignored.

   Examples

      X2C('31 32 73')     @  '12s'
      X2C('313273')       @  '12s'
      X2C('0F')           @  '0F'x

   See Also

      B2X( )      Converts a binary string to a hexadecimal value

      C2X( )      Converts an ASCII character to its value in
                  hexadecimal

      X2B( )      Converts a value in hexadecimal to a binary string



 
                               Chapter 10.
                                 Parsing




      The instructions ARG, PARSE, and PULL parse (split up) a
      character string and assign it to variables, under the control of
      a template.  The template controls how data is parsed among vari-
      ables.  Strings can be parsed by:

      *  Word patterns

      *  String patterns

      *  Numeric patterns

      A basic template consists of alternating pattern specifications
      and variable names.  REXX uses the pattern specifications and
      variables strictly in sequence from left to right, and uses them
      only once.  Templates can have variable names without patterns in
      between, and patterns without intervening variable names.

                                                                                         [96]
      If the first item in a template is a variable, there is an
      implicit pattern on the left that matches the start of the
      string.  Similarly, if the last item in a template is a variable,
      there is an implicit pattern on the right that matches the end of
      the string.  Therefore the simplest template consists of a single
      variable name which in this case is assigned the entire input
      string.

      Setting a variable during parsing is identical to setting a vari-
      able in an assignment.  This means you can set an entire collec-
      tion of compound variables during parsing.  See "Compound
      symbols" on page 19.

      In general, when the parser splits up a character string, it:

      1. Scans the template for patterns, enclosed in quotes.  When it
         finds patterns, it subdivides the data in the character string
         based upon the match of patterns.

      2. Scans the template again for variables.  When it finds vari-
         ables, it assigns the subdivisions to the variables.


   Parsing With Words

      A simple parsing template consists of a list of variable names.
      The parser splits up the string into words (characters delimited
      by blanks), and assigns each word from the string to a variable
      in sequence from left to right.  The final variable is treated
      specially;  the parser assigns to it whatever is left of the
      original string.  The final variable can therefore contain
      several words.  For example:

      'Here today gone tomorrow.' with v1 v2 v3

      sets:

      *  V1 to the value "Here"

      *  V2 to the value "today"

      *  V3 to the value "gone tomorrow."

      The parser removes leading blanks from each word in the string
      before it assigns the word to a variable, as it is the blank that
      delimits the end of the word.  Thus variables set by word
      patterns (V1 and V2 in the example) will never contain leading or
      trailing blanks, though V3 could have both leading and trailing
      blanks.

      If you use PARSE UPPER (or the ARG or PULL instruction), the
      parser translates the whole string into upper case before parsing
      begins.


   Running out of string data

      The parser always assigns every variable in a template a new
      value.  If there are more variables in the template than words in
                                                                                         [97]
      the string, the parser sets the unused variables to a null
      string.


   Parsing With Patterns

      Patterns fall into two categories:

      1. Patterns that search for a matching string

         1) Literal patterns

         2) Variable patterns

      2. Numeric patterns that specify a position in the data

         1) Positional patterns

         2) Relative patterns


   Parsing with literal patterns

      You can use a literal string pattern in a template to split up
      the string.  The string pattern is enclosed in quotes.  The



      parser places input into a variable named in the template until
      the input matches the literal pattern.  The following example
      uses the comma as a pattern.  The parser scans the string for the
      comma, and splits at that point.

      parse value 'Easy come, easy go' with w1 ',' w2

      sets:

      *  W1 to the value "Easy come"

      *  W2 to the value " easy go".

      The parser removes the pattern itself (and only the pattern) from
      the string.  Any remaining input is read into the next variable,
      and so on.

      Another example:

      parse value 'Out of sight, out of mind'
      with s1 ',' w2 w3 w4

      sets:

      *  W2 to the value "out"

      *  W3 to the value "of"

      *  W4 to the value "mind"

      Note that the parser assigns a new value to all variables in a
                                                                                         [98]
      template.

      If a variable is followed by another variable, REXX takes a
      special action.  REXX skips over leading blanks at the current
      position in the input data before it searches for the next blank.
      The value it assigns to the lefthand variable is the next word in
      the string, with no leading or trailing blanks.  For example, the
      template:

      w1  w2  w3 rest ','

      for the PARSE VALUE instruction with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets:

      *  W1 to the value "This"

      *  W2 to the value "is"

      *  W3 to the value "the"

      *  REST to the value "best mouse"



      The final variable, REST, could have both leading and trailing
      blanks, since REXX removes only the blank that delimits the
      previous word.

      This is not the same as specifying explicit blanks as patterns.
      For example, the template:

      w1 ' ' w2 ' ' w3 ' ' rest ','

      for the PARSE VALUE instruction with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets:

      *  W1 to the value "This"

      *  W2 to the value "is"

      *  W3 to the value " " (null)

      *  REST to the value "the best mouse"

      W3 is set to null because the third pattern matches the third
      blank in the data.

      Note: The quotes are not part of the value.  The example shows
      them only to indicate leading or trailing blanks.

      In general then, when a variable follows another variable, it
      implies parsing of the input by tokenization into words.

                                                                                         [99]

   Parsing with variable patterns

      You can specify the pattern as a variable, by putting the vari-
      able name in parentheses.  The following PARSE VALUE instruction
      has the same effect as specifying the comma as a literal string:

      comma=','
      'Out of sight, out of mind' with w1 (comma) w2 w3 w4

      Another example:

      input="D*type the *5 67"
      parse var input  verb 2 delim +1 string (delim) rest

      sets:

      *  VERB to 'D'

      *  DELIM to '*'

      *  STRING to 'type the'

      *  REST to '5 67'


   Running out of pattern matches

      When REXX cannot find a match for a pattern in the input string,
      it "matches" the end of the string.  For example:

      with s1 ',' w2 ',' s3 ',' rest

      for PARSE VALUE instruction with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets:

      *  W1 to the value "This is  the best mouse"

      *  W2 to the value " I think"

      *  W3 to the value "  to buy."

      *  REST to the value " " (null)

      No match was found for the third ',' in the template, and so W3
      was assigned the rest of the string.  REST was assigned a null
      value because the pattern on its left had already reached the end
      of the string.


   Using a placeholder

      A single period acts as a placeholder in a template.  It has
      exactly the same effect as a variable name, except that no vari-
      able is set.  You can use a period as a "dummy variable" in a
      list of variables, to collect unwanted information at the end of
                                                                                         [100]
      a string.  For example:

       . . . word5 .

      extracts the fifth word ('mouse') from the sample string and
      places it in the variable WORD5.


   Parsing with numeric patterns

      A numeric pattern works the same as a string pattern, except you
      specify a column number.  For example, you could use a numeric
      pattern to extract data from particular columns of a record read
      from a file.  For example:

      'Nothing will come of nothing' with x1 5 x2

      splits the string at column 5, and sets:

      *  X1 to the value "Noth"

      *  X2 to the value "ing will come of nothing"



      The numeric pattern can be relative to the last number used.  For
      example:

      'Nothing will come of nothing' with x1 5 x2 +5 x3

      has exactly the same effect as the last example, here the "+5"
      specifies the length of the string to be assigned to X2.

      You can mix string patterns and numeric positions (in effect the
      beginning of a string pattern just specifies a variable column
      number).  This lets you do some very complex parsing with
      templates.


   Parsing with positional patterns

      You can use positional parameters to parse a string based on a
      position within the string, rather than on its contents.

      You can use an unsigned number in a template to specify a partic-
      ular character column in the input.  For example, the template

      s1 10 s2 20 s3

      with the character string:

      'This is  the best mouse, I think,  to buy.'

      sets

      *  S1 to the value "This is  "

      *  S2 to the value "the best m"

                                                                                         [101]
      *  S3 to the value "ouse, I think, to buy."

      The parser assigns S1 the characters from the first through the
      ninth character, and assigns S2 the characters 10 through 19.
      The final variable S3 is set to the remainder of the input.


   Parsing with relative patterns

      You can use signed numbers as patterns to indicate movement rela-
      tive to the character position at which the previous pattern
      match occurred.

      If you specify a signed number, REXX calculates the position for
      the next match by adding (or subtracting) the number given to the
      last matched position.  The last matched position is the position
      of the first character of the match, specified numerically or by
      a string.  For example, the instructions:

      a = '123456789'
      parse var a 3 s1 +3 s2 3 s3

      sets

      *  S1 to the value "345"

      *  S2 to the value "6789"

      *  S3 to the value "3456789"

      The +3 in this example is the same as the absolute number 6 in
      the same position, and works the same as if you assign the length
      of the data string to the variable S1.

      This example also shows the effects of a relative pattern that
      implies movement to a character position to the left of (or to)
      the point at which the last match occurred.  REXX assigns charac-
      ters to the variable on the left through the end of the input,
      and assigns characters to the variable on the right starting at
      the position dictated by the pattern.

      This lets you make multiple assignments.  For example:

      parse var y x1 1 x2 1 x3

      sets X1, X2, and X3 to the entire value of Y.

      If a positional pattern specifies a column that is greater than
      the length of the data, it is the same as specifying the end of
      the data, and no padding takes place.  Similarly, if a pattern
      specifies a column to the left of the first column of the data,
      it is the same as specifying the first column of the data.

      A relative positional pattern can refer to the "last position" in
      a string.  The last position is set to the position in the data
      of the first character in the pattern where the match occurred.
      For example:

      ',' -3 x *=1
                                                                                         [102]

      will:

      1. Find the first comma in the input (or the end of the string if
         there is no comma).

      2. Back up three positions.

      3. Assign one character (the character immediately preceding the
         comma or end of string) to the variable X.

      You can use this type of parsing to look for abbreviations in a
      string.  For example, the instruction:

      parse upper value ' 'note with ' CU' +1 charg ' '

      sets the variable CHARG to the first word in NOTE that starts
      with "CU" or sets it to null if no such word exists.



      Notes:

      1. The positional pattern +0 is valid, and you can use it to
         include the whole of a previous literal (or variable) pattern
         within the data string to be parsed into any following vari-
         ables.

      2. As the last example shows, patterns can follow each other in
         the template without intervening variable names.  In this
         case, each pattern is used in turn from left to right, as
         usual.

      3. If a number in a template is preceded by a +  or a  - , REXX
         recognizes it as a signed positional pattern.  There can be
         blanks between the sign and the number, since REXX removes
         blanks adjacent to special characters.


   Parsing More Than One String

      A parsing template can parse more than one string.  For example,
      an internal function or subroutine can have more than one argu-
      ment string.  To access each string in turn, use a comma in the
      parsing template.  Each comma instructs the parser to move on to
      the next string.

      Multiple strings are used only with the ARG (or PARSE ARG)
      instruction.  For example:

      date('The date is December 31' ,7)
      parse arg first, second

      sets:

      *  FIRST to the value 'The date is December 31'

      *  SECOND to the value 7

                                                                                         [103]
      Between the commas you can put any normal template with patterns
      (and so on) to do more complex parsing on each of the argument
      strings.

      Another example is:

      arg word1 rest1, string2, num

      sets the first word of the first argument string into the vari-
      able WORD1, the rest of that string into REST1, and the next two
      strings into STRING2 and NUM.  If it runs out of strings, REXX
      sets the unused variables to null.



                               Chapter 11.
                            Numerics and Math




      REXX arithmetic follows conventional rules to perform arithmetic
      operations.  The rules are defined so that a program can run on
      different hardware architecture and always produce the same
      result.

      Numbers follow conventional syntax, allowing great flexibility.
      REXX permits leading and trailing blanks, and exponential nota-
      tion.

      The arithmetic operators include addition, subtraction, multipli-
      cation, power, division, integer division, and remainder.


   Numbers

      A number is a character string that includes one or more decimal
      digits, with an optional decimal point.  Some valid numbers are:

      25     An integer or whole number

      .5     A decimal or decimal fraction (one-half).  Equal to 0.5.

      -8     A signed number (minus 8)

      5E6    Floating point number (five million) using exponential
             notation.  The number following the E specifies how many
             places to move the decimal point to the right to make it a
             regular number.

      For a decimal number, you can embed the decimal point in the
      digits, or you can use it as a suffix or prefix.  The group of
      digits (and optional point) can have leading or trailing blanks,
      and an optional sign ("+" or "-"), which must come before any
      digits or decimal point.  The sign can also have leading or
      trailing blanks.

      >>-+------+-+-------------+-+-digits--------+-+------+-----><
         +blanks+ +----sign-----+ +-digits.digits-+ +blanks+
                                                                                         [104]
                                  +-.digits-------+
                                  +-digits. ------+

      Where:

      sign   Either "+" or "-"

      blanks One or more spaces



      digits One or more numeric characters (0 through 9)

      Note:  A single period alone is not a valid number.


   Operators

      The arithmetic operators are:

         Addition  +
         Subtraction  -
         Multiplication  *
         Power  **
         Division  /
         Integer division  %
         Remainder  //

      An operation does not introduce any errors during the operation
      itself except during the final rounding for the result.  

      REXX performs rounding in the "traditional" manner, in that it
      inspects the extra digit, rounds up values of 5 through 9, and
      rounds down values of 0 through 4.

      REXX supplies a conventional zero before a decimal point if
      otherwise there would be no digit preceding it. REXX retains
      significant trailing zeros for addition, subtraction, and multi-
      plication, according to the arithmetic combination rules, except
      that it always expresses a result of zero as the single character
      '0'.  For division, REXX removes trailing zeros after rounding.

      If you find that the default format for a number is not satisfac-
      tory for a particular application, use the FORMAT built-in func-
      tion to control its format.  See page 67.

   Examples

      12+7.00     @ 19
      1.3-1.07    @ 0.23
      1.3-2.07    @ -0.77
      1.20*3      @ 3.6
      7*3         @ 21
      0.9*0.8     @ 0.72
      1/3         @ 0.333333333333333
      2/3         @ 0.666666666666667
      5/2         @ 2.5
      1/10        @ 0.1
      12/12       @ 1
                                                                                         [105]
      8.0/2       @ 4


   Arithmetic combination rules

      This section describes the rules the four basic operators used to
      combine two numbers.  REXX removes insignificant leading zeros
      from all numbers.


   Addition and subtraction

      REXX extends the numbers on the right and left as necessary and
      are then added or subtracted.  For example:

                xxx.xxx + yy.yyyyy

      becomes:

               xxx.xxx00
            +  0yy.yyyyy
               _________
               zzz.zzzzz

      REXX then rounds the result, and removes any insig-
      nificant leading zeros.


   Multiplication

      REXX multiplies the numbers together, using "long multiplica-
      tion".  The result can be as long as the sum of the lengths of
      the operands.  For example:

                xxx.xxx * yy.yyyyy

      becomes:

                zzzzz.zzzzzzzz

      REXX then rounds the result.


   Division

      Before the division, REXX extends the dividend to be at least as
      long as the divisor, taking note of the change in the power of
      ten that this implies.  For example, the division:

             aaa / bbbbb

      becomes:

                   |-------
             bbbbb | aaa00

      REXX then performs traditional long division.    During the divi-
      sion, REXX extends the divisor further as necessary.  It then
      extends the quotient to be the same length as the extended divi-
                                                                                         [106]
      dend (aaa00 and cccc in the example).

                      cccc
                   |-------
             bbbbb | aaa00

      The quotient will not include any leading zeros.
      REXX rounds the quotient, if necessary, and removes any insignif-
      icant trailing zeros.

      Note: Arithmetic operations do not depend on the position of the
      decimal point.  The results of any operation are completely inde-
      pendent of the number of decimal places in the data.  In fact,
      the operations can be carried out as integer operations with the
      exponent being calculated and applied after.


   Additional operators

      In addition to the traditional operators, REXX defines the power
      ( ** ), integer division ( % ), and remainder ( // ) operators.

      The ** (power) operator raises a number to a whole power, which
      can be positive or negative.  If negative, REXX uses the absolute
      value of the power, and then the inverts the result (divides into
      1).  For calculating the result, REXX effectively multiples the
      number by itself for the number of times expressed by the power,
      and finally removes trailing zeros (as though the result were
      divided by one). 


      The % (integer divide) operator divides two numbers and returns
      the integer part of the result, which is not rounded unless the
      integer has more digits than the current setting of the NUMERIC
      DIGITS instruction.  The result returned is that which would
      result from repeatedly subtracting the divisor from the dividend
      while the dividend is larger than the divisor.  During this
      subtraction, REXX uses the absolute values of both the dividend
      and the divisor: the sign of the final result is the same as that
      which would result if normal division were used.  Note that this
      operator might not give the same result as truncating normal
      division (which could be affected by rounding).

      The // (remainder) operator returns the remainder from integer
      division, and is defined as being the residue of the dividend
      after the operation of calculating integer division.  The sign of
      the remainder, if nonzero, is the same as that of the original
      dividend.

   Examples

      2**3                @ 8
      2**-3               @ 0.125
      1.7**8              @ 69.75757441
      2%3                 @ 0
      2.1//3              @ 2.1
      10%3                @ 3
      10//3               @ 1
      -10//3              @ -1
                                                                                         [107]
      10.2//1             @ 0.2
      10//0.3             @ 0.1
      3.6//1.3            @ 1


   Comparing Numbers

      You can use any of the comparative operators to compare numeric
      strings.  However, the strict comparative operators are not
      numeric comparison operators and should not normally be used for
      comparing numbers, since leading and trailing blanks (and leading
      zeros) are significant for these operators.




   Exponential notation

      So far this section has described "pure" numbers.  Although char-
      acter strings that describe numbers can be very long, REXX lets
      you specify a number using exponential notation.  This makes it
      easier to work with both large and small numbers.  In extreme
      cases, exponential notation is needed to make execution possible.



      This extends the definition of numbers by the following:

      >>--+-digits--------+-+-------------------+----------------><
          +-digits.digits-+ +-E-+------+-digits-+
          +-.digits-------+     +-sign-+
          +-digits. ------+

      In other words, you can follow the numeric part of a number by an
      "E" (to indicate exponential notation), an optional sign, and an
      integer following the "E" (or sign) to represents a power of ten
      to apply.  The "E" can be in upper or lower case.  You cannot use
      blanks within this numeric part of a number.

      The following are examples:

      12E11  =  1200000000000
      12E-5  =  0.00012
      -12e4  =  -120000

      You can use all valid numbers as data for arithmetic.  The
      results will be returned in exponential form depending on the
      internal settings.  If the number of places needed before the 
      decimal point exceeds a certain number of digits, REXX uses 
      exponential notation.  
      If you find that the default format for a number is not satisfac-
      tory for a particular application, use the FORMAT built-in func-
      tion to control its format.  The FORMAT function can explicitly
      convert numbers to exponential form or return numbers in "pure"
      form.  See page 67.


                                                                                         [108]
   Use of numbers by REXX

      Whenever REXX uses a character string as a number (for example as
      an argument to a built-in function, or from the result of an
      expression in a DO clause) rounding might occur.


                               Chapter 12.
                             Input and Output




      In most circumstances, a user communicates with a REXX program
      using the standard character input and output streams.  The
      communication to or from the user usually consists of a stream of
      characters on screen.

      *  A character input stream is a serial character stream that is
         either generated by the user, or has the characteristics of a
         stream that is generated by the user.

      *  A character output stream is a serial character stream that
         accepts output from a REXX program.

      Other sources or destinations such as files, serial interfaces,
      displays, or networks can also use the standard character streams
      to communicate with REXX.    The character streams can be tran-
      sient (for example, data sent or received over a serial inter-
      face) or persistent (for example, files and objects).

      In addition, you can use the external data queue to communicate
      between programs.

      *  The external data queue is a queue of character strings.  The
         character strings are arbitrary and have no special meaning or
         effect.

      The external data queue is, by default, the SESSION queue which
      is unique to each edit session and is accessible only to its related
      processes.  

      When you read from or write to a file, you must be consistent
      when you specify the file name.  For example, if you use a path
      prefix with a file name, you must use it the next time you
      specify the file name, or you will get unpredictable results.  An
      easy way to be consistent is to assign the file name to a vari-
      able, and use the variable each time you refer to the file.

      REXX performs any necessary housekeeping (e.g., opening and
      closing files) for character streams automatically.


   Manipulating character streams

      You can use REXX instructions and built-in functions to manipu-
      late the character streams.  For the more general input and
      output streams, you can specify a name for a stream.

      You can manipulate the character input and output streams either
      character-by-character or line-by-line.  However, you can only
                                                                                         [109]
      manipulate the external data queue line-by-line.


   Manipulating input streams

      The following instructions and functions manipulate the input
      stream:

      CHARIN

         Reads one or more characters from a character input stream.
         You can specify a start position for persistent streams.
         Function, see page 57.

      CHARS

         Returns the number of characters currently remaining in a
         character input stream from the read position through the end
         of the stream (including all line-end characters).  Function,
         see page 60.

      LINEIN

         Reads one line from a character input stream.  You can specify
         a line number for persistent streams.  Function, see page 71.

      LINES

         Returns the number of complete lines currently remaining in a
         character input stream.  Function, see page 72.


   Manipulating output streams

      The following instructions and functions manipulate the output
      stream:




      CHAROUT

         Writes zero or more characters to a character output stream.
         This function usually provides complete control over the
         output stream.  You can specify a start position for
         persistent streams.  Function, see page 59.

      LINEOUT

         Writes one line to a character output stream.  Implies an
         appropriate line-end sequence at the end of each line.  You
         can specify a line number for persistent streams.  Function,
         see page 72.

                                                                                         [110]
   Manipulating the external data queue

      The following instructions and functions manipulate the external
      data queue:

      PARSE PULL

         Reads one line from the external data queue.  If the queue is
         empty, it reads a line from the default character input stream
         instead.  This lets you use the external data queue as a
         source for user input, provided that the user input is read as
         lines with these instructions.  Instruction, see page 40.

      PULL

         Performs the same function as PARSE PULL, except that it
         translates the string to upper case.  Instruction, see page
         43.

      PUSH

         Writes one line to the head of the external data queue, as in
         a stack.  Instruction, see page 43.

      QUEUE

         Writes one line to the tail of the external data queue.
         Instruction, see page 44.

      QUEUED

         Returns the number of lines currently available in the
         external data queue.  Function, see page 77.




   Input/Output Examples

   Example

      Display a file, with line numbers          

      1 parse upper arg InFile 
      2 if left(InFile,1) = '"' then
      3    parse var InFile '"' InFile '"' .
      4 else
      5    parse var InFile InFile .
      6 InPath = STREAM(InFile,'C','QUERY EXIST')
      7 if InPath = '' then do
      8    say "File not found" InFile
      9    exit
      10end
      11say "Reading file" InPath
      12say " "
      13LineNumber = 0
      14do while LINES(InFile) > 0
      15   Text = LINEIN(InFile) 
      16   LineNumber = (LineNumber + 1)
      17   Number = right(LineNumber,4,'0')
      18   say Number Text
      19end
      20exit

                                                                                         [111]
        1 :Get command line arguments
        2 :if filename is contained within quotes(eg by Explorer)
        3 :strip them 
        5 :otherwise skip all from first intermediate blank 
        6 :Check that file exists
        7 :If the file was not found,
        8 :Display error message
        9 :And exit this program.
        11:Display path & file name.
        13:Initialize line counter.
        14:While not at end of file,
        15:Read one line, then
        16:Increment our line number,
        17:Format with leading zeros,
        18:And display number & line.
        20:Exit this program.
          
   Example:
          
      Display file information

      1 parse upper arg InFile leftover
      2 InPath = STREAM(InFile,'C','QUERY EXIST')
      3 if InPath = '' then do
      4    say "File not found" InFile
      5    exit
      6 end
      7 Date = STREAM(InFile,'C','QUERY DATETIME')
      8 Size = STREAM(InFile,'C','QUERY SIZE')
      9 say "File path =" InPath
      10say "File date =" Date
      11say "File size =" Size
      12exit

        1:Get command line arguments.
        2:Check that file exists


        3:If the file was not found,
        4:Display a message,
        5:Then exit this program.
        7:Get the file's date & time.
        8:Get the file's size.
        9:Display drive+path+filename.
        10:Display file's date & time.
        11:Display file's size.
        12:Exit this program.

   Example

      Run a program
        /* Sample Procedure to Run a Program */
      1  trace n
      2  SAY 'Enter the New Directory to change to?'
      3  PULL Path
      4  PARSE VALUE Path WITH Drive ':' Rest
      5  IF Rest = '' THEN
      6        Rest = "\"
      7  SAY 'Enter the Program Name to Run?'
                                                                                         [112]
      8  PULL Program
      9  address cms "cmd /C del tmpname.bat"
     10  call STREAM("tmpname.bat","C","OPEN WRITE")
     11  call LINEOUT("tmpname.bat","@ECHO ON") 
     12  call LINEOUT("tmpname.bat",Drive||":") 
     13  call LINEOUT("tmpname.bat","CD" rest) 
     14  call LINEOUT("tmpname.bat",Program) 
     15  call LINEOUT("tmpname.bat","PAUSE") 
     16  call STREAM("tmpname.bat","C","CLOSE")
     17  address cms "cmd /C tmpname.bat"
     18  EXIT
     
      2 ask directory name
      3 accept the name
      4 split drive and directory
      5 if no directory, make it \
      7 ask programname
      8 accept name
      9 delete a temporary file, if exists
        cmd is the name in XP of the Windows-program to execute the DOS-command-processor
        /C is the option for the command processor to execute the string that follows, 
           and next to close the DOS-window 
        del is the DOD-command to delete a file
     10 open tmpname.bat for output
     11 - 15 write 5 lines to the file
     16 close the file
     17 execute the file
 
  
   
                               Chapter 13.
                             Condition Traps




      One important use of the instructions SIGNAL is to
      detect certain REXX program errors. The program errors these
      instructions can detect are called condition traps. See SIGNAL page 47.

      When REXX encounters a SIGNAL ON condition instruction, it sets a condition trap.
      the default is off.

      The following conditions trap command failures:


      NOVALUE  The program used an uninitialized variable.  The vari-
               able is used as:

               *  The name following the VAR subkeyword of the PARSE
                  instruction

               *  A term in an expression

               *  An unassigned variable pattern in a parsing template

                  You can only specify this condition for SIGNAL ON.


                                                                                         [113]
   What Happens When a Condition is Trapped

      When the condition specified with a SIGNAL instruction
      occurs, REXX passes control to a label.  The label 
      depends on whether you used the trapname option when you
      turned on the condition trap:

      *  If you did not specify a trapname, REXX passes control to the
         label that matches the name of the condition:
         NOVALUE.

      *  If you specified a trapname, REXX passes control to that label

      *  If a SIGNAL is executed, the current instruction stops
         executing immediately, the condition is turned off, and the
         SIGNAL instruction executes as usual.  See page 47.

   Remarks

      1. REXX saves the state (ON, OFF) and any trapname of
         each condition trap on entry to a subroutine without affecting
         the conditions set up by the caller.  
      2. An external routine invoked by a CALL does not affect the
         state of condition traps, even if the external routine is a
         REXX program. On entry to any REXX program, all condition
         traps have an initial setting of OFF.

      3. Whenever an event occurs that corresponds to an enabled condi-
         tion, the current instruction terminates and the condition is
         raised immediately.  This means that if an event occurs during
         an instruction, the instruction might not complete execution.

      4. All condition traps are turned off during interactive tracing.
         This prevents any unexpected transfer of control while the
         user is debugging the program.  Also, if a syntax error occurs
         during interactive tracing, it will not cause an exit from the
         program, but is trapped specially and then ignored after a
         message is given.

      5. Labels are clauses consisting of a single symbol followed by a
         colon.  Any number of successive clauses can be labels; there-
         fore multiple labels are allowed before another type of
         clause.

                                                                                         [114]

   --------------------------------------------------------------------
                                  RXFUNCADD
   --------------------------------------------------------------------
   Purpose
      Add an external function to the known declared functions
   Syntax
      RXFUNCADD(systemname, libraryname, rexxname)
   Parameters
      systemname  The name of the routine as known externally
      libraryname The name of the residing library
      rexxname    The name with which the function is called within the Rexx script.
   Remarks
      Returns 0 if the environment knows to find the function.  Otherwise, returns 1.